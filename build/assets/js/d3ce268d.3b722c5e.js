"use strict";(self.webpackChunklux_docs=self.webpackChunklux_docs||[]).push([[904],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var u=a.createContext({}),l=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,u=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=l(n),h=s,m=c["".concat(u,".").concat(h)]||c[h]||d[h]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,r=new Array(i);r[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:s,r[1]=o;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3885:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return d}});var a=n(7462),s=n(3366),i=(n(7294),n(3905)),r=["components"],o={},u="Multi Signature UTXOs with LuxJS",l={unversionedId:"quickstart/multisig-utxos-with-luxjs",id:"quickstart/multisig-utxos-with-luxjs",title:"Multi Signature UTXOs with LuxJS",description:"Introduction",source:"@site/docs/quickstart/multisig-utxos-with-luxjs.md",sourceDirName:"quickstart",slug:"/quickstart/multisig-utxos-with-luxjs",permalink:"/quickstart/multisig-utxos-with-luxjs",draft:!1,editUrl:"https://github.com/luxdefi/network-docs/edit/main/docs/quickstart/multisig-utxos-with-luxjs.md",tags:[],version:"current",frontMatter:{},sidebar:"quickStart",previous:{title:"Transfer LUX Tokens Between Chains",permalink:"/quickstart/cross-chain-transfers"},next:{title:"Lux Transaction Fee",permalink:"/quickstart/transaction-fees"}},p={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Multi-Signature UTXOs",id:"multi-signature-utxos",level:2},{value:"Atomic Transactions",id:"atomic-transactions",level:2},{value:"UTXOs on C-Chain",id:"utxos-on-c-chain",level:2},{value:"Getting Hands-On Multi-Signature UTXOs",id:"getting-hands-on-multi-signature-utxos",level:2},{value:"Setting Up Project",id:"setting-up-project",level:2},{value:"Setting Up APIs and Keychains",id:"setting-up-apis-and-keychains",level:2},{value:"Importing Dependencies and Configurations",id:"importing-dependencies-and-configurations",level:3},{value:"Setup Lux APIs",id:"setup-lux-apis",level:3},{value:"Setup Keychains with Private Keys",id:"setup-keychains-with-private-keys",level:3},{value:"Setup Addresses and Chain IDs",id:"setup-addresses-and-chain-ids",level:3},{value:"Creating Utility Functions",id:"creating-utility-functions",level:2},{value:"Getting Dependencies",id:"getting-dependencies",level:3},{value:"Creating Transferable Output",id:"creating-transferable-output",level:3},{value:"Creating Transferable Input",id:"creating-transferable-input",level:3},{value:"Add Signature Indexes",id:"add-signature-indexes",level:3},{value:"Create EVM Input",id:"create-evm-input",level:3},{value:"Create EVM Output",id:"create-evm-output",level:3},{value:"Update Transfer Class",id:"update-transfer-class",level:3},{value:"Add UTXOs to Inputs",id:"add-utxos-to-inputs",level:3},{value:"Export Utility Functions",id:"export-utility-functions",level:3},{value:"Create Inputs and Outputs",id:"create-inputs-and-outputs",level:2},{value:"Importing Dependencies",id:"importing-dependencies",level:3},{value:"Exporting Functions",id:"exporting-functions",level:3},{value:"Examples",id:"examples",level:2},{value:"Multi-Signature Base Tx on X-Chain",id:"multi-signature-base-tx-on-x-chain",level:2},{value:"Import Dependencies",id:"import-dependencies",level:3},{value:"Send BaseTx",id:"send-basetx",level:3},{value:"Export Multi-Sig UTXO From X to P-Chain",id:"export-multi-sig-utxo-from-x-to-p-chain",level:2},{value:"Import Dependencies",id:"import-dependencies-1",level:3},{value:"Send Export Transaction",id:"send-export-transaction",level:3},{value:"Import Multi-Sig UTXO From X to P-Chain",id:"import-multi-sig-utxo-from-x-to-p-chain",level:2},{value:"Import Dependencies",id:"import-dependencies-2",level:3},{value:"Send Import Transaction",id:"send-import-transaction",level:3},{value:"Import Multi-Sig UTXO From X to C-Chain",id:"import-multi-sig-utxo-from-x-to-c-chain",level:2},{value:"Add Delegator Transaction",id:"add-delegator-transaction",level:2},{value:"Import Dependencies",id:"import-dependencies-3",level:3},{value:"Sending AddDelegator Transaction",id:"sending-adddelegator-transaction",level:3}],c={toc:d};function h(e){var t=e.components,o=(0,s.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"multi-signature-utxos-with-luxjs"},"Multi Signature UTXOs with LuxJS"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"An account on a chain that follows the UTXO model doesn't have a parameter like balance. All it has is a bunch of outputs that are resulted from previous transactions. Each output has some amount of asset associated with them. These outputs can have 1 or multiple owners. The owners are basically the account addresses that can consume this output."),(0,i.kt)("p",null,"The outputs are the result of a transaction that can be spent by the owner of that output. For example, an account has 3 outputs that it can spend, and hence are currently unspent. That is why we call them Unspent Transaction Outputs (UTXOs). So it is better to use the term unspent outputs rather than just outputs. Similarly, we add the amount in the UTXOs owned by an address to calculate its balance. Signing a transaction basically adds the signature of the UTXO owners included in the inputs."),(0,i.kt)("p",null,"If an account A wants to send 1.3 LUX to account B, then it has to include all those unspent outputs in a transaction, that are owned by A and whose sum of amounts in those outputs is more than or equal to 1.3. These UTXOs will be included as inputs in a transaction. Account A also has to create outputs with amount 1.3 and the owner being the receiver (here B). There could be multiple outputs in the outputs array. This means, that using these UTXOs, we can create multiple outputs with different amounts to different addresses."),(0,i.kt)("p",null,"Once the transaction is committed, the UTXOs in the inputs will be consumed and outputs will become new UTXOs for the receiver. If the inputs have more amount unlocked than being consumed by the outputs, then the excess amount will be burned as fees. Therefore, we should also create a change output which will be assigned to us, if there is an excess amount in the input. In the diagram given below, a total of 1.72 LUX is getting unlocked in inputs, therefore we have also created a change output for the excess amount (0.41 LUX) to the sender's address. The remaining amount after being consumed by the outputs like receiver's and change output, is burned as fees (0.01 LUX)."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(9004).Z,width:"2884",height:"688"})),(0,i.kt)("h2",{id:"multi-signature-utxos"},"Multi-Signature UTXOs"),(0,i.kt)("p",null,"UTXOs can be associated with multiple addresses. If there are multiple owners of a UTXO, then we must note the ",(0,i.kt)("inlineCode",{parentName:"p"},"threshold")," value. We have to include signatures of a threshold number of UTXO owners with the unsigned transaction to consume UTXOs present in the inputs. The threshold value of a UTXO is set while issuing the transaction."),(0,i.kt)("p",null,"We can use these multi-sig UTXOs as inputs for multiple purposes and not only for sending assets. For example, we can use them to create Subnets, add delegators, add validators, etc."),(0,i.kt)("h2",{id:"atomic-transactions"},"Atomic Transactions"),(0,i.kt)("p",null,"On Lux, we can even create cross-chain outputs. This means that we can do a native cross-chain transfer of assets. These are made possible through ",(0,i.kt)("strong",{parentName:"p"},"Atomic Transactions"),". This is a 2-step process -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Export transaction on source chain"),(0,i.kt)("li",{parentName:"ul"},"Import transactions on the destination chain")),(0,i.kt)("p",null,"Atomic transactions are similar to other transactions. We use UTXOs of the source chain as inputs and create outputs owned by destination chain addresses. When the export transactions are issued, the newly created UTXOs stay in the ",(0,i.kt)("strong",{parentName:"p"},"Exported Atomic Memory"),". These are neither on the source chain nor on the destination chain. These UTXOs can only be used as inputs by their owners on the destination chain while making import transactions. Using these UTXOs on the atomic memory, we can create multiple outputs with different amounts or addresses."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(4541).Z,width:"3682",height:"854"})),(0,i.kt)("h2",{id:"utxos-on-c-chain"},"UTXOs on C-Chain"),(0,i.kt)("p",null,"We can't use UTXOs on C-Chain to do regular transactions because C-Chain follows the account-based approach. In C-Chain, each address (account) is mapped with its balance, and the assets are transferred simply by adding and subtracting from this balance using the virtual machine."),(0,i.kt)("p",null,"But we can export UTXOs with one or multiple owners to C-Chain and then import them by signing the transaction with the qualified spenders containing those UTXOs as inputs. The output on C-Chain can only have a single owner (a hexadecimal address). Similarly while exporting from C-Chain to other chains, we can have multiple owners for the output, but input will be signed only by the account whose balance is getting used."),(0,i.kt)("h2",{id:"getting-hands-on-multi-signature-utxos"},"Getting Hands-On Multi-Signature UTXOs"),(0,i.kt)("p",null,"Next, we will make utility and other helpful functions, so that, we can use them to create multi-sig UTXOs and spend them with ease. These functions will extract common steps into a function so that we do not have to follow each step every time we are issuing a transaction."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"You can either follow the steps below to get a better understanding of concepts and code or directly clone and test the examples from this ",(0,i.kt)("a",{parentName:"strong",href:"https://github.com/rajranjan0608/multisignature-utxos"},"repo"),".")),(0,i.kt)("h2",{id:"setting-up-project"},"Setting Up Project"),(0,i.kt)("p",null,"Make a new directory ",(0,i.kt)("inlineCode",{parentName:"p"},"multisig")," for keeping all the project codes and move there. First, let's install the required dependencies."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save lux dotenv\n")),(0,i.kt)("p",null,"Now create a configuration file named ",(0,i.kt)("inlineCode",{parentName:"p"},"config.js")," for storing all the pieces of information regarding the network and chain we are connecting to. Since we are making transactions on the Fuji network, its network ID is 5. You can change the configuration according to the network you are using."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'require("dotenv").config()\n\nmodule.exports = {\n  protocol: "https",\n  ip: "api.lux-test.network",\n  port: 443,\n  networkID: 5,\n  privateKeys: JSON.parse(process.env.PRIVATEKEYS),\n  mnemonic: process.env.MNEMONIC,\n}\n')),(0,i.kt)("p",null,"Create a ",(0,i.kt)("inlineCode",{parentName:"p"},".env")," file for storing sensitive information which we can't make public like the private keys or the mnemonic. Here are the sample private keys, which you should not use. You can create a new account on ",(0,i.kt)("a",{parentName:"p",href:"https://wallet.lux.network/"},"Lux Wallet")," and paste the mnemonic here for demonstration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-env"},'PRIVATEKEYS=`[\n    "PrivateKey-ewoqjP7PxY4yr3iLTpLisriqt94hdyDFNgchSxGGztUrTXtNN",\n    "PrivateKey-R6e8f5QSa89DjpvL9asNdhdJ4u8VqzMJStPV8VVdDmLgPd8a4"\n]`\nMNEMONIC="mask stand appear..."\n')),(0,i.kt)("h2",{id:"setting-up-apis-and-keychains"},"Setting Up APIs and Keychains"),(0,i.kt)("p",null,"Create a file ",(0,i.kt)("inlineCode",{parentName:"p"},"importAPI.js")," for importing and setting up all the necessary APIs, Keychains, addresses, etc. Now paste the following snippets into the file."),(0,i.kt)("h3",{id:"importing-dependencies-and-configurations"},"Importing Dependencies and Configurations"),(0,i.kt)("p",null,"We need dependencies like the LuxJS module and other configurations. Let's import them at the top."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const { Lux, BinTools, BN } = require("lux")\nconst Web3 = require("web3")\n\nconst MnemonicHelper = require("lux/dist/utils/mnemonic").default\nconst HDNode = require("lux/dist/utils/hdnode").default\nconst { privateToAddress } = require("ethereumjs-util")\n\n// Importing node details and Private key from the config file.\nconst {\n  ip,\n  port,\n  protocol,\n  networkID,\n  privateKeys,\n  mnemonic,\n} = require("./config.js")\n\nlet { luxAssetID, chainIDs } = require("./constants.js")\n\n// For encoding and decoding to CB58 and buffers.\nconst bintools = BinTools.getInstance()\n')),(0,i.kt)("h3",{id:"setup-lux-apis"},"Setup Lux APIs"),(0,i.kt)("p",null,"To make API calls to the Lux network and different blockchains like X-Chain, P-Chain and C-Chain, let's set up these by adding the following code snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Lux instance\nconst lux = new Lux(ip, port, protocol, networkID)\nconst nodeURL = `${protocol}://${ip}:${port}/ext/bc/C/rpc`\nconst web3 = new Web3(nodeURL)\n\n// Platform and Lux API\nconst platform = lux.PChain()\nconst lux = lux.XChain()\nconst evm = lux.CChain()\n")),(0,i.kt)("h3",{id:"setup-keychains-with-private-keys"},"Setup Keychains with Private Keys"),(0,i.kt)("p",null,"In order to sign transactions with our private keys, we will use the LuxJS keychain API. This will locally store our private keys and can be easily used for signing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Keychain for signing transactions\nconst keyChains = {\n  x: lux.keyChain(),\n  p: platform.keyChain(),\n  c: evm.keyChain(),\n}\n\nfunction importPrivateKeys(privKey) {\n  keyChains.x.importKey(privKey)\n  keyChains.p.importKey(privKey)\n  keyChains.c.importKey(privKey)\n}\n")),(0,i.kt)("p",null,"We can either use mnemonics to derive private keys from it or simply use the bare private key for importing keys to the keychain. We can use the following function to get private keys from the mnemonic and address index which we want. For demo purposes, we will use addresses at index 0 and 1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function getPrivateKey(mnemonic, activeIndex = 0) {\n  const mnemonicHelper = new MnemonicHelper()\n  const seed = mnemonicHelper.mnemonicToSeedSync(mnemonic)\n  const hdNode = new HDNode(seed)\n\n  const luxPath = `m/44'/9000'/0'/0/${activeIndex}`\n\n  return hdNode.derive(luxPath).privateKeyCB58\n}\n\n// importing keys in the key chain - use this if you have any private keys\n// privateKeys.forEach((privKey) => {\n//  importPrivateKeys(privKey)\n// })\n\n// importing private keys from mnemonic\nimportPrivateKeys(getPrivateKey(mnemonic, 0))\nimportPrivateKeys(getPrivateKey(mnemonic, 1))\n")),(0,i.kt)("h3",{id:"setup-addresses-and-chain-ids"},"Setup Addresses and Chain IDs"),(0,i.kt)("p",null,"For creating transactions we might need addresses of different formats like ",(0,i.kt)("inlineCode",{parentName:"p"},"Buffer")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Bech32")," etc. And to make issue transactions on different chains we need their ",(0,i.kt)("inlineCode",{parentName:"p"},"chainID"),". Paste the following snippet to achieve the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Buffer representation of addresses\nconst addresses = {\n  x: keyChains.x.getAddresses(),\n  p: keyChains.p.getAddresses(),\n  c: keyChains.c.getAddresses(),\n}\n\n// String representation of addresses\nconst addressStrings = {\n  x: keyChains.x.getAddressStrings(),\n  p: keyChains.p.getAddressStrings(),\n  c: keyChains.c.getAddressStrings(),\n}\n\nluxAssetID = bintools.cb58Decode(luxAssetID)\n\nchainIDs = {\n  x: bintools.cb58Decode(chainIDs.x),\n  p: bintools.cb58Decode(chainIDs.p),\n  c: bintools.cb58Decode(chainIDs.c),\n}\n\n// Exporting these for other files to use\nmodule.exports = {\n  networkID,\n  platform,\n  lux,\n  evm,\n  keyChains,\n  luxAssetID,\n  addresses,\n  addressStrings,\n  chainIDs,\n  bintools,\n  web3,\n  BN,\n}\n")),(0,i.kt)("p",null,"We can use the above-exported variables and APIs from other files as required."),(0,i.kt)("h2",{id:"creating-utility-functions"},"Creating Utility Functions"),(0,i.kt)("p",null,"While creating multi-sig transactions, we have a few things in common, like creating inputs with the UTXOs, creating outputs, and adding signature indexes. So let's create a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"utils.js")," and paste the following snippets that we can call every time we want to do a repetitive task."),(0,i.kt)("h3",{id:"getting-dependencies"},"Getting Dependencies"),(0,i.kt)("p",null,"Inputs and outputs are an array of transferable input and transferable output. These contain transfer inputs and associated assetID which is being transferred. There are different types of transfer inputs/outputs for sending assets, minting assets, minting NFTs, etc."),(0,i.kt)("p",null,"We will be using ",(0,i.kt)("inlineCode",{parentName:"p"},"SECPTransferInput/SECPTransferOutput")," for sending our assets."),(0,i.kt)("p",null,"But since we can't use UTXOs on C-Chain, we cannot directly import them either. Therefore we need to create a different type of input/output for them called ",(0,i.kt)("inlineCode",{parentName:"p"},"EVMInput/EVMOutput"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const { BN, chainIDs, web3 } = require("./importAPI")\n\nlet SECPTransferInput,\n  TransferableInput,\n  SECPTransferOutput,\n  TransferableOutput,\n  EVMInput,\n  EVMOutput\n\nconst getTransferClass = (chainID) => {\n  let vm = ""\n  if (chainID.compare(chainIDs.x) == 0) {\n    vm = "avm"\n  } else if (chainID.compare(chainIDs.p) == 0) {\n    vm = "platformvm"\n  } else if (chainID.compare(chainIDs.c) == 0) {\n    vm = "evm"\n  }\n  return ({\n    SECPTransferInput,\n    TransferableInput,\n    SECPTransferOutput,\n    TransferableOutput,\n    EVMInput,\n    EVMOutput,\n    index,\n  } = require(`lux/dist/apis/${vm}/index`))\n}\n')),(0,i.kt)("p",null,"Different chains have their own implementation of TransferInput/Output classes. Therefore we need to update the required modules according to the chain we issuing transactions on. To make it more modular, we created a ",(0,i.kt)("inlineCode",{parentName:"p"},"getTransferClass()")," function, that will take ",(0,i.kt)("inlineCode",{parentName:"p"},"chainID")," and import modules as required."),(0,i.kt)("h3",{id:"creating-transferable-output"},"Creating Transferable Output"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createOutput()")," function will create and return the transferable output according to arguments amount, assetID, owner addresses, locktime, and threshold. Locktime represents the timestamp after which this output could be spent. Mostly this parameter will be 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const createOutput = (amount, assetID, addresses, locktime, threshold) => {\n  let transferOutput = new SECPTransferOutput(\n    amount,\n    addresses,\n    locktime,\n    threshold\n  )\n\n  return new TransferableOutput(assetID, transferOutput)\n}\n")),(0,i.kt)("h3",{id:"creating-transferable-input"},"Creating Transferable Input"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createInput()")," function will create and return transferable input. Input require arguments like amount in the UTXO, and arguments which identify that UTXO, like txID of the transaction which the UTXO was the output of, outputIndex (index of the output in that tx), and qualified signatures (output spenders which are present in our keychain) whose signature will be required while signing this transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const createInput = (\n  amount,\n  txID,\n  outputIndex,\n  assetID,\n  spenders,\n  threshold\n) => {\n  // creating transfer input\n  let transferInput = new SECPTransferInput(amount)\n\n  // adding threshold signatures\n  addSignatureIndexes(spenders, threshold, transferInput)\n\n  // creating transferable input\n  return new TransferableInput(txID, outputIndex, assetID, transferInput)\n}\n")),(0,i.kt)("h3",{id:"add-signature-indexes"},"Add Signature Indexes"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createSignatureIndexes()")," function will add spender addresses along with an index for each address in the transfer input. While signing the unsigned transaction, these signature indexes will be used."),(0,i.kt)("p",null,"By adding signature indexes we are not signing the inputs but just adding a placeholder of the address at a particular index whose signature is required when we call the ",(0,i.kt)("inlineCode",{parentName:"p"},".sign()")," function on the unsigned transactions. Once the threshold spender addresses are added, it will exit."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const addSignatureIndexes = (addresses, threshold, input) => {\n  let sigIndex = 0\n  addresses.every((address) => {\n    if (threshold > 0) {\n      input.addSignatureIdx(sigIndex, address)\n      sigIndex++\n      threshold--\n      return true\n    } else {\n      return false\n    }\n  })\n}\n")),(0,i.kt)("h3",{id:"create-evm-input"},"Create EVM Input"),(0,i.kt)("p",null,"As explained earlier, we do not have UTXOs on C-Chain. Therefore we cannot make regular inputs. The following function ",(0,i.kt)("inlineCode",{parentName:"p"},"createEVMInput()")," will create the required input and add a signature index corresponding to the address specified in the input."),(0,i.kt)("p",null,"EVM Inputs are required when we want to export assets from C-Chain. In the following function, ",(0,i.kt)("inlineCode",{parentName:"p"},"addresses")," is the array of Buffer addresses but for ",(0,i.kt)("inlineCode",{parentName:"p"},"C-Chain Export Transactions"),", a hex address is also appended at last."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const createEVMInput = (amount, addresses, assetID, nonce) => {\n  const hexAddress = addresses.at(-1)\n  const evmInput = new EVMInput(hexAddress, amount, assetID, nonce)\n  evmInput.addSignatureIdx(0, addresses[0])\n\n  return evmInput\n}\n")),(0,i.kt)("h3",{id:"create-evm-output"},"Create EVM Output"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createEVMOutput()")," function will create EVM output for importing assets on C-Chain."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const createEVMOutput = (amount, hexAddress, assetID) => {\n  return new EVMOutput(hexAddress, amount, assetID)\n}\n")),(0,i.kt)("h3",{id:"update-transfer-class"},"Update Transfer Class"),(0,i.kt)("p",null,"Let's make a small function that will call the ",(0,i.kt)("inlineCode",{parentName:"p"},"getTransferClass()")," according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"chainID"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const updateTransferClass = (chainID) => {\n  {\n    SECPTransferInput,\n      TransferableInput,\n      SECPTransferOutput,\n      TransferableOutput,\n      EVMInput,\n      EVMOutput,\n      (index = getTransferClass(chainID))\n  }\n}\n")),(0,i.kt)("h3",{id:"add-utxos-to-inputs"},"Add UTXOs to Inputs"),(0,i.kt)("p",null,"We have ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," as an array of UTXOs that will be consumed in the transaction. The ",(0,i.kt)("inlineCode",{parentName:"p"},"updateInputs()")," function will take UTXOs, ",(0,i.kt)("inlineCode",{parentName:"p"},"addresses")," whose credentials we have for signing, ",(0,i.kt)("inlineCode",{parentName:"p"},"assetID")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"toBeUnlocked")," i.e. amount we want to consume. ",(0,i.kt)("inlineCode",{parentName:"p"},"toBeUnlocked")," contains everything we want to consume including transfer amount, fees, stake amount (if any), etc."),(0,i.kt)("p",null,"We also have a special variable ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),", that will indicate the type of transaction which is associated with the C-Chain. This is required because -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Export from C-Chain (C.export == true) - These types of transactions cannot have UTXOs as inputs and therefore ",(0,i.kt)("inlineCode",{parentName:"li"},"EVMInput")," is created."),(0,i.kt)("li",{parentName:"ul"},"Import to C-Chain (C.import == true) - The outputs imported on C-Chain from exported UTXOs are ",(0,i.kt)("inlineCode",{parentName:"li"},"EVMOutput"),".")),(0,i.kt)("p",null,"It will create inputs with the passed UTXOs worth the ",(0,i.kt)("inlineCode",{parentName:"p"},"toBeUnlocked")," amount. But if there is a UTXO that when included, will surpass the ",(0,i.kt)("inlineCode",{parentName:"p"},"toBeUnlocked")," amount, then it will create a change output with the qualified spenders as their new owners with the surpassed amount."),(0,i.kt)("p",null,"This function will return the ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," array containing all the unlocked UTXOs, change transferable output, and the net balance included in these inputs. Now add the following function snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const updateInputs = async (\n  utxos,\n  addresses,\n  C,\n  assetID,\n  toBeUnlocked,\n  chainID\n) => {\n  // Getting transferable inputs according to chain id\n  updateTransferClass(chainID)\n\n  let inputs = [],\n    changeTransferableOutput = undefined,\n    netInputBalance = new BN(0)\n\n  if (C.export) {\n    const nonce = await web3.eth.getTransactionCount(addresses.at(-1))\n    inputs.push(createEVMInput(toBeUnlocked, addresses, assetID, nonce))\n  } else {\n    utxos.forEach((utxo) => {\n      let output = utxo.getOutput()\n      if (\n        output.getOutputID() === 7 &&\n        assetID.compare(utxo.getAssetID()) === 0 &&\n        netInputBalance < toBeUnlocked\n      ) {\n        let outputThreshold = output.getThreshold()\n\n        // spenders which we have in our keychain\n        let qualifiedSpenders = output.getSpenders(addresses)\n\n        // create inputs only if we have custody of threshold or more number of utxo spenders\n        if (outputThreshold <= qualifiedSpenders.length) {\n          let txID = utxo.getTxID()\n          let outputIndex = utxo.getOutputIdx()\n          let utxoAmount = output.amountValue\n          let outputLocktime = output.getLocktime()\n\n          netInputBalance = netInputBalance.add(utxoAmount)\n\n          let excessAmount = netInputBalance.sub(toBeUnlocked)\n\n          // creating change transferable output\n          if (excessAmount > 0) {\n            if (!C.import) {\n              changeTransferableOutput = createOutput(\n                excessAmount,\n                assetID,\n                qualifiedSpenders,\n                outputLocktime,\n                outputThreshold\n              )\n            }\n          }\n\n          // create transferable input\n          let transferableInput = createInput(\n            utxoAmount,\n            txID,\n            outputIndex,\n            assetID,\n            qualifiedSpenders,\n            outputThreshold\n          )\n\n          inputs.push(transferableInput)\n        }\n      }\n    })\n  }\n  return { inputs, changeTransferableOutput }\n}\n")),(0,i.kt)("p",null,"Only those UTXOs will be included whose output ID is ",(0,i.kt)("inlineCode",{parentName:"p"},"7")," representing ",(0,i.kt)("inlineCode",{parentName:"p"},"SECPTransferOutput"),". These outputs are used for transferring assets. Also, we are only including outputs containing ",(0,i.kt)("inlineCode",{parentName:"p"},"LUX")," assets. These conditions are checked in the following line -"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"if(output.getOutputID() === 7 && assetID.compare(utxo.getAssetID()) === 0 && netInputBalance < toBeUnlocked) {\n")),(0,i.kt)("p",null,"The following part in the above function creates the change output if the total included balance surpasses the required amount and the transaction is not a C-Chain export -"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"netInputBalance = netInputBalance.add(utxoAmount)\n\nlet excessAmount = netInputBalance.sub(toBeUnlocked)\n\n// creating change transferable output\nif (excessAmount > 0) {\n  if (!C.import) {\n    changeTransferableOutput = createOutput(\n      excessAmount,\n      assetID,\n      qualifiedSpenders,\n      outputLocktime,\n      outputThreshold\n    )\n  }\n}\n")),(0,i.kt)("h3",{id:"export-utility-functions"},"Export Utility Functions"),(0,i.kt)("p",null,"Now paste the following snippet to export these utility functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"module.exports = {\n  createOutput,\n  createEVMOutput,\n  updateInputs,\n}\n")),(0,i.kt)("p",null,"All the utility functions are created."),(0,i.kt)("h2",{id:"create-inputs-and-outputs"},"Create Inputs and Outputs"),(0,i.kt)("p",null,"Let's create a function that will return the array of sufficient UTXOs stuffed inside an array and necessary outputs like send output, multi-sig output, evm output, change output, etc. This function is basically a wrapper that orchestrates the utility and other functions to generate inputs and outputs from parameters like addresses, asset id, chain id, output arguments (to, threshold and amount), etc."),(0,i.kt)("p",null,"Now make a new file ",(0,i.kt)("inlineCode",{parentName:"p"},"createInputsAndOutputs.js")," and paste the following snippets of code inside it."),(0,i.kt)("h3",{id:"importing-dependencies"},"Importing Dependencies"),(0,i.kt)("p",null,"We need to import utility functions for creating outputs and inputs with the UTXOs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const { BN, lux, platform, evm, chainIDs, bintools } = require("./importAPI")\n\nconst { createOutput, createEVMOutput, updateInputs } = require("./utils")\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EVMInput")," should be used as inputs while creating an export transaction from C-Chain and ",(0,i.kt)("inlineCode",{parentName:"p"},"EVMOutput")," should be used as outputs while creating an import transaction on C-Chain. To make it easier to decide when to do what, let's make a function ",(0,i.kt)("inlineCode",{parentName:"p"},"checkChain()")," that will return an object ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," (described earlier)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const checkChain = (chainID, ownerAddress) => {\n  let C = {\n    export: false,\n    import: false,\n  }\n  if (chainID.compare(chainIDs.c) == 0) {\n    if (typeof ownerAddress == "string" && bintools.isHex(ownerAddress)) {\n      C.import = true\n    } else {\n      C.export = true\n    }\n  }\n  return C\n}\n')),(0,i.kt)("p",null,"For getting UTXOs from an address, let's make another function ",(0,i.kt)("inlineCode",{parentName:"p"},"getUnspentOutputs()"),". This function will fetch UTXOs from a given address and source chain. The ",(0,i.kt)("inlineCode",{parentName:"p"},"sourceChain")," will be used to fetch exported UTXOs that are not yet imported. The exported outputs stay in the exported atomic memory. This parameter will only be used when we want to import assets."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// UTXOs for spending unspent outputs\nconst getUnspentOutputs = async (\n  addresses,\n  chainID,\n  sourceChain = undefined\n) => {\n  let utxoSet\n  if (chainID.compare(chainIDs.x) == 0) {\n    utxoSet = await lux.getUTXOs(addresses, sourceChain)\n  } else if (chainID.compare(chainIDs.p) == 0) {\n    utxoSet = await platform.getUTXOs(addresses, sourceChain)\n  }\n  return utxoSet.utxos.getAllUTXOs()\n}\n")),(0,i.kt)("p",null,"Now for organizing inputs and outputs and adding required signature indexes (not signatures) for each unspent output, adding change output, etc, we will make a ",(0,i.kt)("inlineCode",{parentName:"p"},"createInputsAndOutputs()")," function. Paste the following snippet next."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const createInputsAndOutputs = async (\n  assetID,\n  chainID,\n  addresses,\n  addressStrings,\n  outputConfig,\n  fee,\n  sourceChain\n) => {\n  let locktime = new BN(0)\n\n  let C = checkChain(chainID, outputConfig[0].owners)\n\n  let utxos = []\n  if (C.export) {\n    addresses.push("0x3b0e59fc2e9a82fa5eb3f042bc5151298e4f2cab") // getHexAddress(addresses[0])\n  } else {\n    utxos = await getUnspentOutputs(addressStrings, chainID, sourceChain)\n  }\n\n  let toBeUnlocked = fee\n  outputConfig.forEach((output) => {\n    toBeUnlocked = toBeUnlocked.add(output.amount)\n  })\n\n  // putting right utxos in the inputs\n  let { inputs, changeTransferableOutput } = await updateInputs(\n    utxos,\n    addresses,\n    C,\n    assetID,\n    toBeUnlocked,\n    chainID\n  )\n\n  let outputs = []\n\n  // creating transferable outputs and transfer outputs\n  outputConfig.forEach((output) => {\n    let newOutput\n    if (!C.import) {\n      newOutput = createOutput(\n        output.amount,\n        assetID,\n        output.owners,\n        locktime,\n        output.threshold\n      )\n    } else {\n      newOutput = createEVMOutput(output.amount, output.owners, assetID)\n    }\n    outputs.push(newOutput)\n  })\n\n  // pushing change output (if any)\n  if (changeTransferableOutput != undefined && !C.import) {\n    outputs.push(changeTransferableOutput)\n  }\n\n  return { inputs, outputs }\n}\n')),(0,i.kt)("p",null,"Output config is basically an array of all outputs that we want to create. This excludes the change output because it will be automatically created. It has the following structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// Regular outputs\n;[\n  {\n    amount: BigNumber,\n    owners: [Buffer],\n    threshold: Number,\n  },\n][\n  // Import to C-Chain\n  {\n    amount: BigNumber,\n    owners: "hex address string",\n  }\n]\n')),(0,i.kt)("p",null,"You will learn about these arguments and how we can actually pass this along with other arguments through the examples ahead."),(0,i.kt)("h3",{id:"exporting-functions"},"Exporting Functions"),(0,i.kt)("p",null,"Add the following snippet to export this function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"module.exports = {\n  createInputsAndOutputs,\n}\n")),(0,i.kt)("p",null,"We have created all the utility and helper functions. You can use this project structure to create different types of transactions like BaseTx, Export, Import, AddDelegator, etc. You should have the following files in your project now -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},".env")," - Secret file storing data like mnemonic and private keys"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"config.js")," - Network information and parsed data from ",(0,i.kt)("inlineCode",{parentName:"li"},".env")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"constants.js")," - Asset and Chain specific static data"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"importAPI.js")," - Import and setup apis, addresses and keychains"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"utils.js")," - Utility functions for creating inputs and outputs"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"createInputsAndOutputs.js")," - Wrapper of ",(0,i.kt)("inlineCode",{parentName:"li"},"utility.js")," for orchestrating utility functions.")),(0,i.kt)("p",null,"Follow the next steps for ",(0,i.kt)("strong",{parentName:"p"},"examples")," and on how to use these functions."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Now let's look at the examples for executing these transactions. For example, we will create a separate ",(0,i.kt)("inlineCode",{parentName:"p"},"examples")," folder. In order to run the example scripts, you must be in the root folder where all the environment variables and configurations are kept."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"node examples/send.js\n")),(0,i.kt)("h2",{id:"multi-signature-base-tx-on-x-chain"},"Multi-Signature Base Tx on X-Chain"),(0,i.kt)("p",null,"Let's create a base transaction that converts a single-owner UTXO into a multi-sig UTXO. The final UTXO can be used by new owners of the unspent output by adding their signatures for each output. Create a new file ",(0,i.kt)("inlineCode",{parentName:"p"},"sendBaseTx.js")," and paste the following snippets."),(0,i.kt)("h3",{id:"import-dependencies"},"Import Dependencies"),(0,i.kt)("p",null,"Import the necessary dependencies like ",(0,i.kt)("inlineCode",{parentName:"p"},"keyChains"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"addresses"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"utility")," functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"UnSignedTx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseTx")," classes etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  lux,\n} = require("../importAPI")\n\nconst { UnsignedTx, BaseTx } = require("lux/dist/apis/avm/index")\n\nconst { createInputsAndOutputs } = require("../createMultisig")\n')),(0,i.kt)("h3",{id:"send-basetx"},"Send BaseTx"),(0,i.kt)("p",null,"Now create the ",(0,i.kt)("inlineCode",{parentName:"p"},"sendBaseTx()")," function to be called for sending base tx to the network."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'async function sendBaseTx() {\n  let memo = Buffer.from("Multisig Base Tx")\n\n  // unlock amount = sum(output amounts) + fee\n  let fee = new BN(1e6)\n\n  // creating outputs of 0.5 (multisig) and 0.1 LUX - change output will be added by the function in the last\n  let outputConfig = [\n    {\n      amount: new BN(5e8),\n      owners: addresses.x,\n      threshold: 2,\n    },\n    {\n      amount: new BN(1e8),\n      owners: [addresses.x[1]],\n      threshold: 1,\n    },\n  ]\n\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.x,\n    addresses.x,\n    addressStrings.x,\n    outputConfig,\n    fee\n  )\n\n  const baseTx = new BaseTx(networkID, chainIDs.x, outputs, inputs, memo)\n\n  const unsignedTx = new UnsignedTx(baseTx)\n  const tx = unsignedTx.sign(keyChains.x)\n  const txID = await lux.issueTx(tx)\n  console.log("TxID:", txID)\n}\n')),(0,i.kt)("p",null,"We have created the BaseTx with the following output configuration -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Multi-sig output of value 0.5 LUX with threshold 2 and owners represented by ",(0,i.kt)("inlineCode",{parentName:"li"},"addresses.x"),". The owners are basically an array of addresses in Buffer representation."),(0,i.kt)("li",{parentName:"ul"},"Single owner output of value 0.1 LUX.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let outputConfig = [\n  {\n    amount: new BN(5e8),\n    owners: addresses.x,\n    threshold: 2,\n  },\n  {\n    amount: new BN(1e8),\n    owners: [addresses.x[1]],\n    threshold: 1,\n  },\n]\n")),(0,i.kt)("p",null,"Let's discuss the arguments of ",(0,i.kt)("inlineCode",{parentName:"p"},"createInputsAndOutputs()")," in detail -"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"assetID")," - ID of the asset involved in transaction"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"chainID")," - ID of the chain on which this transaction will be issued"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"addresses")," - Addresses buffer array whose UTXO will be consumed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"addressStrings")," - Addresses string array whose UTXO will be consumed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"outputConfig")," - Array of output object containing amount, owners and threshold"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"fee")," - Fee for this transaction to be consumed in inputs"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"sourceChain")," - Chain from which UTXOs will be fetched. Will take ",(0,i.kt)("inlineCode",{parentName:"li"},"chainID")," as default.")),(0,i.kt)("p",null,"In the above parameters, if ",(0,i.kt)("inlineCode",{parentName:"p"},"fee")," is less than the fees actually required for that transaction, then there will be no surplus amount left by outputs over inputs because any surplus will be converted into a change output. This can cause transaction failure. So keep the fees in accordance with the transaction as mentioned ",(0,i.kt)("a",{parentName:"p",href:"/quickstart/transaction-fees#fee-schedule"},"here"),"."),(0,i.kt)("p",null,"Also, the ",(0,i.kt)("inlineCode",{parentName:"p"},"sourceChain")," parameter is required for fetching exported UTXOs that do not exist yet on the destination chain. For non-export/import transactions, this parameter is not required."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createInputsAndOutputs()")," function will return ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs")," required for any transaction. The last element of the outputs array would be change output. And the order of other outputs will be the same as that in the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputConfig"),". Signature indexes corresponding to their owners are already included in the inputs. We can create an unsigned base transaction using the ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseTx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsignedTx")," classes as shown above. The ",(0,i.kt)("inlineCode",{parentName:"p"},".sign()")," function basically adds the required signatures from the keychain at the place indicated by signature indexes."),(0,i.kt)("p",null,"Once the multi-sig UTXO is created, this UTXO can only be used if we have the threshold signers in our keychain. The util functions can be tweaked a little bit to create and return inputs with a part number of signers (<threshold). We can then partially sign the inputs and ask other owners to add signature index and sign."),(0,i.kt)("p",null,"Now call the ",(0,i.kt)("inlineCode",{parentName:"p"},"sendBaseTx()")," function by adding this line"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"sendBaseTx()\n")),(0,i.kt)("p",null,"Run this file using ",(0,i.kt)("inlineCode",{parentName:"p"},"node examples/sendBaseTx.js"),", see the txID in the output, and look for it in the Fuji explorer."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8058).Z,width:"2900",height:"1148"})),(0,i.kt)("h2",{id:"export-multi-sig-utxo-from-x-to-p-chain"},"Export Multi-Sig UTXO From X to P-Chain"),(0,i.kt)("p",null,"Now we will look into exporting assets from the X to P chain. It will be similar to the BaseTx example, with few differences in output ordering and cross-chain owner addresses."),(0,i.kt)("p",null,"Make a new file named ",(0,i.kt)("inlineCode",{parentName:"p"},"exportXP.js")," and paste the following snippets."),(0,i.kt)("h3",{id:"import-dependencies-1"},"Import Dependencies"),(0,i.kt)("p",null,"This time we will require ",(0,i.kt)("inlineCode",{parentName:"p"},"ExportTx")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseTx")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  lux,\n} = require("../importAPI")\n\nconst { UnsignedTx, ExportTx } = require("lux/dist/apis/avm/index")\n\nconst { createInputsAndOutputs } = require("../createMultisig")\n')),(0,i.kt)("h3",{id:"send-export-transaction"},"Send Export Transaction"),(0,i.kt)("p",null,"Most of the things will be very much similar in this function. You can have a look at ",(0,i.kt)("inlineCode",{parentName:"p"},"outputConfig"),", which creates a multi-sig output for addresses on P-Chain. These addresses will be required for signing importTx on P-Chain."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fee")," here will only be for exporting the asset. The import fees will be deducted from the UTXOs present on the ",(0,i.kt)("strong",{parentName:"p"},"Exported Atomic Memory"),", a memory location where UTXOs lie after getting exported but before being imported. If there is only a single UTXO, then it will be deducted from it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'async function exportXP() {\n  let memo = Buffer.from("Multisig Export Tx")\n\n  // consuming amount = sum(output amount) + fee\n  let fee = new BN(1e6)\n\n  // creates mutlti-sig (0.1 LUX) and single-sig (0.03 LUX) output for exporting to P Address (0.001 LUX will be fees)\n  let outputConfig = [\n    {\n      amount: new BN(3e6),\n      owners: [addresses.p[0]],\n      threshold: 1,\n    },\n    {\n      amount: new BN(1e8),\n      owners: addresses.p,\n      threshold: 2,\n    },\n  ]\n\n  // importing fees will be deducted from these our other outputs in the exported output memory\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.x,\n    addresses.x,\n    addressStrings.x,\n    outputConfig,\n    fee\n  )\n\n  // outputs at index 0 and 1 are to be exported\n  const exportTx = new ExportTx(\n    networkID,\n    chainIDs.x,\n    [outputs.at(-1)],\n    inputs,\n    memo,\n    chainIDs.p,\n    [outputs[0], outputs[1]]\n  )\n\n  const unsignedTx = new UnsignedTx(exportTx)\n  const tx = unsignedTx.sign(keyChains.x)\n  const txID = await lux.issueTx(tx)\n  console.log("TxID:", txID)\n}\n')),(0,i.kt)("p",null,"Another point to note is how inputs, outputs, and exportedOutputs are passed here."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inputs are as usual passed for the ",(0,i.kt)("inlineCode",{parentName:"li"},"ins")," parameter of the ",(0,i.kt)("inlineCode",{parentName:"li"},"ExportTx")," class."),(0,i.kt)("li",{parentName:"ul"},"But only ",(0,i.kt)("inlineCode",{parentName:"li"},"outputs. at(-1)")," representing change output (last element) is passed in place of the usual ",(0,i.kt)("inlineCode",{parentName:"li"},"outs")," param."),(0,i.kt)("li",{parentName:"ul"},"The last param of this class is ",(0,i.kt)("inlineCode",{parentName:"li"},"exportedOuts"),", representing the outputs that will be exported from this chain to ",(0,i.kt)("inlineCode",{parentName:"li"},"destinationChain")," (2nd last param).")),(0,i.kt)("p",null,"All these inputs and outputs are array, and hence con contains multiple outputs or inputs. But you have to manage which output should be passed where."),(0,i.kt)("p",null,"Call the function by adding the below function call."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"exportXP()\n")),(0,i.kt)("p",null,"Run this file using ",(0,i.kt)("inlineCode",{parentName:"p"},"node examples/exportXP.js"),", see the txID in the output, and look for it in the ",(0,i.kt)("a",{parentName:"p",href:"https://explorer-xp.lux-test.network/blockchain/2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm"},"Fuji explorer"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(1831).Z,width:"2898",height:"1296"})),(0,i.kt)("p",null,"In the above image, we are consuming UTXO with the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"0.486..."),", and generating outputs with the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"0.382...")," (change output) and ",(0,i.kt)("inlineCode",{parentName:"p"},"0.003")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"0.1")," (exported output). The remaining ",(0,i.kt)("inlineCode",{parentName:"p"},"0.001")," is burned as transaction fees."),(0,i.kt)("h2",{id:"import-multi-sig-utxo-from-x-to-p-chain"},"Import Multi-Sig UTXO From X to P-Chain"),(0,i.kt)("p",null,"After exporting the UTXOs from the source chain, it stays in the exported atomic memory i.e. these are neither on the source chain nor on the destination chain. Paste the following snippets into a new file ",(0,i.kt)("inlineCode",{parentName:"p"},"importP.js"),"."),(0,i.kt)("h3",{id:"import-dependencies-2"},"Import Dependencies"),(0,i.kt)("p",null,"We will require ",(0,i.kt)("inlineCode",{parentName:"p"},"ImportTx")," from PlatformVM APIs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  platform,\n} = require("../importAPI")\n\nconst { UnsignedTx, ImportTx } = require("lux/dist/apis/platformvm/index")\n\nconst { createInputsAndOutputs } = require("../createMultisig")\n')),(0,i.kt)("h3",{id:"send-import-transaction"},"Send Import Transaction"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"importP()")," is a simple function that will use UTXOs on the exported atomic memory as its inputs and create an output on the P-Chain addresses. You can change the output config's owners and amount as per your need."),(0,i.kt)("p",null,"An important point to note here is that all UTXOs that are included in this ",(0,i.kt)("inlineCode",{parentName:"p"},"importTx")," will be transferred to the destination chain. Even if the import amount is less than the amount in the UTXO, it will be sent to the qualified spender on the destination chain as a change output."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'async function importP() {\n  let memo = Buffer.from("Multisig Import Tx")\n\n  // Use this parameter if you have UTXOs exported from other chains - only exported outputs will be fetched\n  let sourceChain = "X"\n\n  // unlock amount = sum(output amount) + fee\n  let fee = new BN(1e6)\n\n  let outputConfig = [\n    {\n      amount: new BN(1e6),\n      owners: addresses.p,\n      threshold: 2,\n    },\n    {\n      amount: new BN(1e2),\n      owners: addresses.p[0],\n      threshold: 1,\n    },\n  ]\n\n  // all the inputs here are the exported ones due to source chain parameter\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.p,\n    addresses.p,\n    addressStrings.p,\n    outputConfig,\n    fee,\n    sourceChain\n  )\n\n  const importTx = new ImportTx(\n    networkID,\n    chainIDs.p,\n    outputs,\n    [],\n    memo,\n    chainIDs.x,\n    inputs\n  )\n\n  const unsignedTx = new UnsignedTx(importTx)\n  const tx = unsignedTx.sign(keyChains.x)\n  const txID = await platform.issueTx(tx)\n  console.log("TxID:", txID)\n}\n')),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(2521).Z,width:"2922",height:"1392"})),(0,i.kt)("p",null,"In the above image, we are consuming the above exported UTXOs with amounts ",(0,i.kt)("inlineCode",{parentName:"p"},"0.003")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"0.1"),", and generating outputs with amount ",(0,i.kt)("inlineCode",{parentName:"p"},"0.092...")," (change output imported on P-Chain) and 2 ",(0,i.kt)("inlineCode",{parentName:"p"},"0.005")," imported outputs (1 multi-sig and 1 single-sig). The remaining ",(0,i.kt)("inlineCode",{parentName:"p"},"0.001")," is burned as transaction fees."),(0,i.kt)("h2",{id:"import-multi-sig-utxo-from-x-to-c-chain"},"Import Multi-Sig UTXO From X to C-Chain"),(0,i.kt)("p",null,"This transaction will also be similar to other atomic transactions, except for the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputConfig")," parameter. You can easily get the idea by looking at the code below. Before you can run this example, there must be exported outputs for the addresses you control on the C-Chain, otherwise, there will be no UTXO to consume."),(0,i.kt)("p",null,"Here we are importing UTXOs that are exported from X-Chain."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  evm,\n} = require("../importAPI")\n\nconst { UnsignedTx, ImportTx } = require("lux/dist/apis/evm/index")\n\nconst { createInputsAndOutputs } = require("../createMultisig")\n\nasync function importP() {\n  // Use this parameter if you have UTXOs exported from other chains - only exported outputs will be fetched\n  let sourceChain = "X"\n\n  // unlock amount = sum(output amount) + fee (fees on C-Chain is dynamic)\n  let fee = new BN(0)\n\n  let outputConfig = [\n    {\n      amount: new BN(1e4),\n      owners: "0x4406a53c35D05424966bD8FC354E05a3c6B56aF0",\n    },\n    {\n      amount: new BN(2e4),\n      owners: "0x3b0e59fc2e9a82fa5eb3f042bc5151298e4f2cab",\n    },\n  ]\n\n  // all the inputs here are the exported ones due to source chain parameter\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.c,\n    addresses.c,\n    addressStrings.c,\n    outputConfig,\n    fee,\n    sourceChain\n  )\n\n  const importTx = new ImportTx(\n    networkID,\n    chainIDs.c,\n    chainIDs.x,\n    inputs,\n    outputs\n  )\n\n  const unsignedTx = new UnsignedTx(importTx)\n  const tx = unsignedTx.sign(keyChains.x)\n  const txID = await evm.issueTx(tx)\n  console.log("TxID:", txID)\n}\n\nimportP()\n')),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8197).Z,width:"2976",height:"634"})),(0,i.kt)("p",null,"You can use ",(0,i.kt)("a",{parentName:"p",href:"https://testnet.luxscan.io/"},"Luxscan")," to view import and export transactions on C-Chain."),(0,i.kt)("h2",{id:"add-delegator-transaction"},"Add Delegator Transaction"),(0,i.kt)("p",null,"Till now we have covered common transactions like BaseTx, Export, and Import Tx. Export and Import Tx will be similar in all the UTXO-based chains like X and P. But for Account-based chains, we have to deal with an account-balance system."),(0,i.kt)("p",null,"Now let's try using the multi-sig UTXOs exported from X-Chain to P-Chain to issue an ",(0,i.kt)("inlineCode",{parentName:"p"},"addDelegator()")," transaction. Create a file ",(0,i.kt)("inlineCode",{parentName:"p"},"addDelegatorTx.js")," and paste the following snippets."),(0,i.kt)("h3",{id:"import-dependencies-3"},"Import Dependencies"),(0,i.kt)("p",null,"Import the dependencies like ",(0,i.kt)("inlineCode",{parentName:"p"},"AddDelegatorTx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsignedTx")," classes using the following code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  platform,\n} = require("../importAPI")\n\nconst {\n  UnsignedTx,\n  AddDelegatorTx,\n  SECPOwnerOutput,\n  ParseableOutput,\n} = require("lux/dist/apis/platformvm/index")\n\nconst { NodeIDStringToBuffer, UnixNow } = require("lux/dist/utils")\n\nconst { createInputsAndOutputs } = require("../createMultisig")\n')),(0,i.kt)("h3",{id:"sending-adddelegator-transaction"},"Sending AddDelegator Transaction"),(0,i.kt)("p",null,"Now we will create the ",(0,i.kt)("inlineCode",{parentName:"p"},"addDelegator()")," function which will use the multi-sig UTXOs and create a signed ",(0,i.kt)("inlineCode",{parentName:"p"},"addDelegatorTx"),", which when issued, will add the delegator to the specified node. Paste the following snippet next."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'async function addDelegator() {\n  let nodeID = NodeIDStringToBuffer("NodeID-4B4rc5vdD1758JSBYL1xyvE5NHGzz6xzH")\n  let locktime = new BN(0)\n  let stakeAmount = await platform.getMinStake()\n  let startTime = UnixNow().add(new BN(60 * 1))\n  let endTime = startTime.add(new BN(2630000))\n  let memo = Buffer.from("Multi-sig Add Delegator Tx")\n\n  // unlock amount = sum(output amounts) + fee\n  let fee = new BN(1e6)\n\n  // creating stake amount output at 0th index\n  let outputConfig = [\n    {\n      amount: stakeAmount.minValidatorStake,\n      owners: addresses.p,\n      threshold: 2,\n    },\n  ]\n\n  // outputs to be created for rewards\n  const rewardOutputOwners = new SECPOwnerOutput(addresses.p, locktime, 2)\n  const rewardOwners = new ParseableOutput(rewardOutputOwners)\n\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.p,\n    addresses.p,\n    addressStrings.p,\n    outputConfig,\n    fee\n  )\n\n  const addDelegatorTx = new AddDelegatorTx(\n    networkID,\n    chainIDs.p,\n    [],\n    inputs,\n    memo,\n    nodeID,\n    startTime,\n    endTime,\n    stakeAmount.minDelegatorStake,\n    [outputs[0]],\n    rewardOwners\n  )\n\n  const unsignedTx = new UnsignedTx(addDelegatorTx)\n  const tx = unsignedTx.sign(keyChains.p)\n  const txID = await platform.issueTx(tx)\n  console.log("TxID:", txID)\n}\n')),(0,i.kt)("p",null,"In the above transaction, the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs")," param will be empty since we do not need to transfer any assets to the account. As you can see above we need to create another type of output, for indicating the reward for delegation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const rewardOutputOwners = new SECPOwnerOutput(addresses.p, locktime, 2)\nconst rewardOwners = new ParseableOutput(rewardOutputOwners)\n")),(0,i.kt)("p",null,"Call the function by adding the below function call."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"addDelegator()\n")),(0,i.kt)("p",null,"Run this file using ",(0,i.kt)("inlineCode",{parentName:"p"},"node examples/addDelegatorTx.js"),", see the txID in the output, and look for it in the Fuji explorer."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(4594).Z,width:"2924",height:"982"})))}h.isMDXComponent=!0},9004:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-1-a60c23955fd177745fae878daf48ece8.png"},4541:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-2-09c94f21882e66e8cb1e93a4bb4fb4ef.png"},8058:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-3-f49fd0484a493384994f35a959df1404.jpeg"},1831:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-4-9c29655cd14943ac02c3416f17466917.jpeg"},2521:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-5-88bd53a31b32624020a7167b00aecc2c.jpeg"},8197:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-6-c79629a0c68986569f79d629f33bb763.png"},4594:function(e,t,n){t.Z=n.p+"assets/images/multisig-utxos-7-f7a371772af20b296b4f82baf9d9697b.jpeg"}}]);