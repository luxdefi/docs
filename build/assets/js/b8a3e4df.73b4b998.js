"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8839],{10333:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=t(85893),o=t(11151);const r={},i="SubnetBridge.sol",a={id:"deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/SubnetBridge.sol",title:"SubnetBridge.sol",description:"",source:"@site/docs/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/SubnetBridge.sol.md",sourceDirName:"deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge",slug:"/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/SubnetBridge.sol",permalink:"/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/SubnetBridge.sol",draft:!1,unlisted:!1,editUrl:"https://github.com/luxdefi/docs/edit/master/docs/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/SubnetBridge.sol.md",tags:[],version:"current",frontMatter:{}},d={},c=[];function u(n){const e={code:"code",h1:"h1",pre:"pre",...(0,o.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"subnetbridgesol",children:"SubnetBridge.sol"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport "../Token/INativeMinter.sol";\n\ncontract SubnetBridge {\n    address public admin;\n    /* Address to send tokens to burn them */\n    address public burnAddress = address(0x0);\n    /* Gets incremented with each `burn()`, indicates the transferCount\n    and prevents double processing the event */\n    uint public nonce;\n\n    /* Represents NativeMinterInterface */\n    NativeMinterInterface public nativeMinter =\n        NativeMinterInterface(\n            /*\n                Native Minter contract is always at this address\n                as explained at https://docs.lux.network/subnets/customize-a-subnet#minting-native-coins\n             */\n            address(0x0200000000000000000000000000000000000001)\n        );\n\n    /* Mapping to hold whether nonce is processed or not */\n    mapping(uint => bool) public processedNonces;\n\n    /* Allows us to indicate whether it is a `mint()` or `burn()` when emitting an event */\n    enum Type {\n        Mint,\n        Burn\n    }\n\n    /*\n        Event that is emitted with both `mint()` and `burn()`\n        Relayer listens to events emitted by `burn()`\n        Potential frontend application may want to listen to events emitted by `mint()`\n    */\n    event Transfer(\n        address from,\n        address to,\n        uint amount,\n        uint time,\n        uint nonce,\n        Type indexed transferType\n    );\n\n    /* Modifier to allow some functions to be only called by admin */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, "only admin");\n        _;\n    }\n\n    /* Constructor that sets admin as the sender */\n    constructor() {\n        admin = msg.sender;\n    }\n\n    /* Function to allow setting new admin */\n    function setAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /* Function that is called by the relayer to mint some tokens after it is locked on the lux */\n    function mint(\n        address to,\n        uint amount,\n        uint luxNonce\n    ) external onlyAdmin {\n        require(processedNonces[luxNonce] == false, "nonce already processed");\n        processedNonces[luxNonce] = true;\n\n        nativeMinter.mintNativeCoin(to, amount);\n        emit Transfer(\n            msg.sender,\n            to,\n            amount,\n            block.timestamp,\n            luxNonce,\n            Type.Mint\n        );\n    }\n\n    /*\n        Function that is called by the user to burn their tokens.\n        Relayer listens to this event and if the nonce is not processed,\n        it will call `release()` of the LuxBridge\n    */\n    function burn(address to) external payable {\n        require(msg.value > 0, "You have to burn more than 0 tokens");\n        /* Send native token to 0x0 address, effectively burning native token */\n        (bool sent, ) = payable(burnAddress).call{value: msg.value}("");\n        require(sent, "Failed to send native token");\n\n        /* Event that is emitted for relayer to process */\n        emit Transfer(\n            msg.sender,\n            to,\n            msg.value,\n            block.timestamp,\n            nonce,\n            Type.Burn\n        );\n\n        /* Increment the nonce to prevent double counting */\n        nonce++;\n    }\n}\n'})})]})}function l(n={}){const{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(u,{...n})}):u(n)}},11151:(n,e,t)=>{t.d(e,{Z:()=>a,a:()=>i});var s=t(67294);const o={},r=s.createContext(o);function i(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);