"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2759],{56616:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(85893),r=t(11151);const o={},i="How to Use The Graph to Query Lux Data",s={id:"deprecated/tutorials-contest/2021/pangolin-token-subgraph/README",title:"How to Use The Graph to Query Lux Data",description:"These tutorials were published as a snapshot of when they were written,",source:"@site/docs/deprecated/tutorials-contest/2021/pangolin-token-subgraph/README.md",sourceDirName:"deprecated/tutorials-contest/2021/pangolin-token-subgraph",slug:"/deprecated/tutorials-contest/2021/pangolin-token-subgraph/",permalink:"/deprecated/tutorials-contest/2021/pangolin-token-subgraph/",draft:!1,unlisted:!1,editUrl:"https://github.com/luxdefi/docs/edit/main/docs/deprecated/tutorials-contest/2021/pangolin-token-subgraph/README.md",tags:[],version:"current",frontMatter:{}},h={},l=[{value:"Table of Content",id:"table-of-content",level:2},{value:"Introduction",id:"introduction",level:2},{value:"What Is the Graph",id:"what-is-the-graph",level:2},{value:"The Graph and Open APIs",id:"the-graph-and-open-apis",level:2},{value:"GraphQL Introduction",id:"graphql-introduction",level:2},{value:"What Is Lux",id:"what-is-lux",level:2},{value:"The Graph and Lux",id:"the-graph-and-lux",level:2},{value:"Interacting with Lux Data via the Graph: Pangolin Example",id:"interacting-with-lux-data-via-the-graph-pangolin-example",level:2},{value:"How to Build a Subgraph",id:"how-to-build-a-subgraph",level:2},{value:"How to Deploy a Subgraph",id:"how-to-deploy-a-subgraph",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"how-to-use-the-graph-to-query-lux-data",children:"How to Use The Graph to Query Lux Data"}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"These tutorials were published as a snapshot of when they were written,\nand may contain out-of-date-information.\nFor up-to-date information, please reach out to the owners of these\nprojects."})}),"\n",(0,a.jsx)(n.h2,{id:"table-of-content",children:"Table of Content"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#what-is-the-graph",children:"What is The Graph"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#the-graph-and-open-apis",children:"The Graph and Open APIs"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#graphql-introduction",children:"GraphQL Introduction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#what-is-lux",children:"What is Lux"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#the-graph-and-lux",children:"The Graph and Lux"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#interacting-with-data-via-the-graph-pangolin-example",children:"Interacting with Lux Data via the Graph: Pangolin Example"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#how-to-build-a-subgraph",children:"How to Build a Subgraph"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#how-to-deploy-a-subgraph",children:"How to Deploy a Subgraph"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["The importance of data is nowadays encapsulated by the saying, \u201cdata is the new\noil\u201d. What this means is that properly harnessed data is now an invaluable part\nof any economic strategy, information gathering, or decision-making process as\ninsights gleaned from data can open up productive opportunities and serve as a\ncompetitive advantage. The new economy that is being created by the innovation\nof ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Blockchain",children:"blockchain"})," technology is no\nexception. Blockchain data is notoriously difficult to index and query as there\nisn\u2019t an inbuilt query language as with traditional databases. Thankfully,\nbreakthroughs and new approaches are being made in this space to facilitate data\naccessibility. One of such protocols that seek to simplify the handling of\nblockchain data is ",(0,a.jsx)(n.a,{href:"https://thegraph.com/",children:"The Graph"}),". In this tutorial, you\nwill be taught how to query data from ",(0,a.jsx)(n.a,{href:"https://www.lux.network/",children:"Lux"}),"\nblockchain using The Graph. Lux is a next-generation blockchain that lays\nemphasis on being incredibly fast, low-cost, and scalable. It is also\neco-friendly as it relies on a novel approach to consensus, more on this later.\nThe layout of this tutorial is divided into three broad logical sections. First,\nyou will be introduced to The Graph protocol, its mission of creating open APIs\nstandards, and the underlying query language it utilizes,\n",(0,a.jsx)(n.a,{href:"https://graphql.org/",children:"GraphQL"}),". Second, you will be given an overview of\nLux, how it differs from competitor blockchains, and its design decisions\nthat aid developer onboarding and satisfaction. Third, you will be shown how to\ntie the concepts learned from The Graph and Lux to develop a sound data\nstrategy that enables efficient querying of Lux data in your Lux\napplications. By the end of this tutorial, you will be well vested with the\nknowledge required to create your own data-driven Lux applications."]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-the-graph",children:"What Is the Graph"}),"\n",(0,a.jsxs)(n.p,{children:["The Graph is an open-source protocol for indexing and querying blockchain data.\nThe main value proposition of The Graph is to enable anyone to create open APIs\nthat power a decentralized future. Unlike traditional APIs in the Web2 world\nwhich are often centralized, proprietary, and have gatekeepers that restrict\naccess, The Graph envisions an open ecosystem of APIs where one API can be built\non top of another without needing permission. This can be achieved through the\nusage of ",(0,a.jsx)(n.a,{href:"https://thegraph.com/explorer",children:"subgraphs"})," which can be thought of as\nAPIs assembled through The Graph that index specific data and exposes querying\ncapabilities to other users. The network of various subgraphs exposes a global\ngraph that provides access to public information in an open and transparent way."]}),"\n",(0,a.jsxs)(n.p,{children:["The Graph is currently made up of two types of services, a ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/",children:"hosted\nservice"}),", and a ",(0,a.jsx)(n.a,{href:"https://thegraph.com/explorer/network",children:"decentralized Graph\nnetwork"}),". The hosted service is free to\nuse and supports a wide range of blockchains like Lux, Ethereum, Fantom,\nPolygon, Binance Smart Chain (BSC), etc. alongside several testnets of the\naforementioned chains. The decentralized Graph network on the other hand\ncurrently only supports Ethereum, however, the long-term vision is to have it\nsupport other chains as in the hosted service. The main difference between both\nis that the hosted service is a centralized offering where the nodes are run and\nmaintained by The Graph\u2019s own team, whereas the Graph network is a decentralized\noffering in which members of the public can operate nodes that support and\nguarantee the security of the network in a permissionless manner. The token of\nThe Graph decentralized network is GRT (The Graph) and various actors in the\necosystem are incentivized through token inflation to bootstrap the network.\nDevelopers can create subgraphs and have indexers run nodes that index those\nsubgraphs, just as curators can signal or support reliable subgraphs through\ntheir tokens while delegators who may be non-technical can still contribute to\nthe network by delegating their token to indexers (those who run nodes). The\ndecentralized network is thus more censorship-resistant than the hosted service\nand as it matures in production, it will eventually support other blockchains\napart from Ethereum and eclipse the hosted service which came first."]}),"\n",(0,a.jsxs)(n.p,{children:["If you look under the hood of The Graph protocol, you will discover that the\nhosted service and the decentralized Graph network both rely on an open-source\nimplementation of a ",(0,a.jsx)(n.a,{href:"https://github.com/graphprotocol/graph-node",children:"Graph Node"}),".\nThe Graph  Node is a software that can be run which deterministically stores\nevents triggered from blockchains such as Ethereum in a data store. For the\ninitial implementation, the data store used was\n",(0,a.jsx)(n.a,{href:"https://www.postgresql.org/",children:"PostgreSQL"}),",  and a Graph Node is usually expected\nto be run alongside an ",(0,a.jsx)(n.a,{href:"https://ipfs.io/",children:"IPFS"})," node and a full node capable of\nvalidating all data from that blockchain, for example, an Ethereum full node.\nWith the hosted service, you do not need to run these nodes as they are managed\nfor you. As a result, the hosted service is a great place to start using The\nGraph and all examples in this tutorial will use the hosted service."]}),"\n",(0,a.jsx)(n.h2,{id:"the-graph-and-open-apis",children:"The Graph and Open APIs"}),"\n",(0,a.jsx)(n.p,{children:"In this section of the tutorial, you will be shown the integral pieces of The\nGraph protocol, how they fit together and what a typical workflow looks like."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Schematic Diagram of The Graph Protocol",src:t(11539).Z+"",title:"Schematic Diagram of The Graph Protocol",width:"910",height:"633"})}),"\n",(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://github.com/graphprotocol/graph-node/blob/master/docs/getting-started.md",children:"https://github.com/graphprotocol/graph-node/blob/master/docs/getting-started.md"})]}),"\n",(0,a.jsxs)(n.p,{children:["The schematic diagram above is an overview of a dapp using The Graph protocol\nand it contains the components and typical workflow involved. At the center is\nthe Graph Node which was talked about in the last section, it listens to events\ntriggered by smart contracts on the blockchain that it indexes and records those\nevents as data in a store through a predefined mapping (the\n",(0,a.jsx)(n.a,{href:"https://webassembly.org/",children:"WASM"})," module) that transforms that data into the\ndesired format. The Graph Node exposes a GraphQL API that the dapp can use to\nquery data from the blockchain it wants to display in the frontend. When such\nqueries are received, Graph Node retrieves the relevant data from the attached\nstore and serves the requests. Note that transactions in the dapp are initiated\ndirectly on the smart contracts on the blockchain and do not pass through Graph\nNode as there is no write capability. The Graph protocol is used to index and\nquery historic data so it can be seen as having a read-only mechanism. However,\nas a  result of its architecture, caching, and storage, data is queried\nefficiently since relevant events were indexed earlier. This is a much better\napproach than having dapps query the blockchain directly to read historic data."]}),"\n",(0,a.jsxs)(n.p,{children:["To better understand the workflow of The Graph protocol, it can be easier to\nthink of it as being made up of three components, the Graph Node, the ",(0,a.jsx)(n.a,{href:"https://github.com/graphprotocol/graph-cli",children:"Graph\nCLI"}),", and the ",(0,a.jsx)(n.a,{href:"https://github.com/graphprotocol/graph-ts",children:"Graph Typescript\nLibrary"}),". The Graph Node has been\nexplained extensively above, the Graph CLI is a Command Line Interface through\nwhich you can interact with The Graph protocol and do things like create a\nsubgraph, unregister a subgraph, generate scripts for smart contracts to be\nindexed, deploy a subgraph to the Graph Node, etc. The Graph TypeScript Library\nprovides a set of helper APIs for you to access the underlying store, blockchain\ndata, smart contracts, IPFS files, cryptographic functions, etc. It can be\nthought of as providing a connector/mapping from one domain to the other. ",(0,a.jsx)(n.br,{}),"\n","The entry point of a subgraph project is the manifest file. It contains the\ngeneral definitions of the subgraph such as the smart contracts being indexed,\nthe names of events of interest, the handler functions that are triggered on\nthose events,  etc. Other important files that make up a subgraph project are\nthe GraphQL schema file, the mappings file that contains code that dictates how\nentities are accessed and stored, and a bunch of other auto-generated files\nwhich you will understand in-depth in subsequent sections. For now, the most\nimportant thing to understand is that the Graph protocol exposes blockchain data\nvia GraphQL APIs, and it does this through an internal mapping of that data to a\nlocal store."]}),"\n",(0,a.jsx)(n.h2,{id:"graphql-introduction",children:"GraphQL Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["GraphQL is a query language for APIs and it solves some of the pain points\nassociated with traditional APIs that use the\n",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Representational_state_transfer",children:"REST"})," framework.\nWith GraphQL, data can be gotten from different resources in a single request as\nthere is no need for multiple round trips to different endpoints to fetch data.\nGraphQL also enables frontend clients to describe and request exactly the data\nthey are interested in unlike REST APIs where data that may not be required by\nthe client is returned simply because it is a part of that endpoint. GraphQL\nuses a single endpoint to serve requests as it relies on the concept of types\nand fields so your APIs can evolve without the need for explicit versioning,\nrather new fields, and types can be added. This decouples API design from the\nfrontend structure as APIs can be developed independently and frontends can ask\nfor only data they are interested in with guarantees that they will receive that\ndata if they follow the schema provided by the GraphQL API."]}),"\n",(0,a.jsxs)(n.p,{children:["GraphQL defines three ",(0,a.jsx)(n.a,{href:"https://graphql.org/learn/schema/",children:"operation types"}),"\nnamely Query, Mutation, and Subscription. In this tutorial, you will concentrate\non the ",(0,a.jsx)(n.a,{href:"https://thegraph.com/docs/developer/graphql-api",children:"features of GraphQL as relates to The\nGraph"}),". The Graph only supports\nthe Query type, which as the name implies is used for querying (retrieving)\ndata. Mutations represent actions that can change or update data and are not\nsupported as dapp developers are expected to interact directly with the\nunderlying blockchain through transactions. Subscriptions are used for\nmaintaining an existing connection from a client to a GraphQL server and are not\nsupported by The Graph."]}),"\n",(0,a.jsx)(n.p,{children:"In GraphQL, the Query type is the entry point to the API, The Graph defines an\nEntity type for its schema but automatically creates the Query type as the\ntop-level type (root type) for you with fields - entity and entities. Below is\nan example."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Token @entity {\n  id: ID!\n  address: Bytes!\n  name: String!\n  symbol: String\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The entity in this example is Token, the @entity directive is provided by The\nGraph and will create fields token and tokens in the automatically generated\nQuery type. Note that these fields generated are what will be used in\nconstructing a GraphQL query as you will see shortly. The fields in the Token\nentity - id, address, name, symbol are the data that will be returned if they\nare included as part of a query. An entity must also include an id field for it\nto be considered valid. The exclamation mark indicates that the field is NON\nNULLABLE, which means it will always have a value."}),"\n",(0,a.jsx)(n.p,{children:"By looking at the GraphQL schema above, you can construct a query that closely\nmirrors it and includes only the data you are interested in. An example query is\nshown below."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  token(id: "1") {\n    id\n    address\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The example query is for a specific token entity with an ",(0,a.jsx)(n.code,{children:"id"})," of ",(0,a.jsx)(n.code,{children:"1"}),". When\nquerying for a single entity in The Graph, the ",(0,a.jsx)(n.code,{children:"id"})," field must be included. The\nresult returned will mirror the query structure and will only include data\nrequested for which in this case is the ",(0,a.jsx)(n.code,{children:"id"})," and ",(0,a.jsx)(n.code,{children:"address"})," fields. A  probable\nresult is shown below."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  "data": {\n    "token": {\n    "id": "0x10",\n    "address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"\n   }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can also query for all tokens (entities) using the query below."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  tokens {\n    id\n    address\n    name\n    symbol\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The results will match the query structure and will be an array of tokens with\nthe additional fields - ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"symbol"})," included because they were requested\nfor unlike in the last query example."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  "data": {\n    "tokens": [\n      {\n        "id": "0x10",\n        "address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",\n        "name": "Wrapped Ether",\n        "symbol": "WETH"\n      },\n      {\n        "id": "0x11",\n        "address": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",\n        "name": "Wrapped BTC",\n        "symbol": "WBTC"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The Graph also includes support for sorting, pagination, filtering, time-travel\nqueries, etc. please refer to ",(0,a.jsx)(n.a,{href:"https://thegraph.com/docs/developer/graphql-api",children:"The Graph\ndocumentation"})," for a full list\nof features."]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-lux",children:"What Is Lux"}),"\n",(0,a.jsxs)(n.p,{children:["Lux can best be described as a blockchain ecosystem and smart contracts\nplatform that is built from the ground up to combat the notion that blockchains\nare inherently slow and not scalable. The architecture of Lux is comprised\nof ",(0,a.jsx)(n.a,{href:"https://docs.lux.network/learn/platform-overview",children:"3 main chains"})," which\nderive their security guarantees from the ",(0,a.jsx)(n.a,{href:"https://support.lux.network/en/articles/4135650-what-is-the-primary-network",children:"primary\nnetwork"}),".\nThe chains are the ",(0,a.jsx)(n.a,{href:"https://docs.lux.network/build/apis/luxd/apis/x-chain",children:"Exchange Chain\n(X-Chain)"}),", the\n",(0,a.jsx)(n.a,{href:"https://docs.lux.network/build/apis/luxd/apis/p-chain",children:"Platform Chain\n(P-Chain)"}),", and\nthe ",(0,a.jsx)(n.a,{href:"https://docs.lux.network/build/apis/luxd/apis/c-chain",children:"Contract Chain\n(C-Chain)"}),". The\nExchange Chain is used for creating and trading digital assets and relies on\nLux Consensus Protocol, the Platform Chain is used for creating new\n",(0,a.jsx)(n.a,{href:"https://docs.lux.network/subnets",children:"Subnets"})," and custom blockchains. The\nContract Chain is an instance of the ",(0,a.jsx)(n.a,{href:"https://ethereum.org/en/developers/docs/evm/",children:"Ethereum Virtual Machine\n(EVM)"})," running on Lux.\nLux, therefore supports Ethereum tooling and\n",(0,a.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.7/",children:"Solidity"})," as smart contracts built\nfor Ethereum can be deployed on the Contract Chain with the added benefit of\nincreased throughput. Decentralized applications can also be built natively for\nthe Contract Chain using tools like ",(0,a.jsx)(n.a,{href:"https://metamask.io/",children:"MetaMask"}),",\n",(0,a.jsx)(n.a,{href:"https://www.trufflesuite.com/",children:"Truffle"}),", ",(0,a.jsx)(n.a,{href:"https://getwaffle.io/",children:"Waffle"}),",\n",(0,a.jsx)(n.a,{href:"https://remix.ethereum.org/",children:"Remix"}),". etc. For more explanations about concepts\nin Lux, you can consult the official\n",(0,a.jsx)(n.a,{href:"https://docs.lux.network/",children:"documentation"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Below is a diagram that further illustrates the points discussed."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Lux Architecture",src:t(13770).Z+"",title:"Lux Architecture",width:"814",height:"407"})}),"\n",(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://docs.lux.network/learn/platform-overview",children:"https://docs.lux.network/learn/platform-overview"})]}),"\n",(0,a.jsx)(n.h2,{id:"the-graph-and-lux",children:"The Graph and Lux"}),"\n",(0,a.jsxs)(n.p,{children:["In line with The Graph\u2019s vision of providing open access to the world\u2019s data and\nLux\u2019s goal of being an open, programmable, smart contracts platform that\npowers the next wave of scalable decentralized applications, both entities\n",(0,a.jsx)(n.a,{href:"https://medium.com/luxlux/integrates-the-graph-to-bring-its-querying-and-indexing-to-536e48043486",children:"announced a\npartnership"}),"\nthat allows on-chain data from Lux to be indexed and queried through The\nGraph protocol. This means that Web3 developers can now access Lux data\nthrough subgraphs and build data-intensive applications while also having access\nto data from other blockchains supported by The Graph protocol."]}),"\n",(0,a.jsx)(n.h2,{id:"interacting-with-lux-data-via-the-graph-pangolin-example",children:"Interacting with Lux Data via the Graph: Pangolin Example"}),"\n",(0,a.jsxs)(n.p,{children:["In this section, you will learn how to query Lux data from an already\ndeployed subgraph on The Graph\u2019s ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/",children:"hosted\nservice"}),". The subgraph you will use\nindexes data from the ",(0,a.jsx)(n.a,{href:"https://pangolin.exchange/",children:"Pangolin"})," decentralized\nexchange on Lux. Pangolin is an ",(0,a.jsx)(n.a,{href:"https://support.lux.network/en/articles/4840276-what-is-an-automated-market-maker-amm",children:"Automated Market Maker\n(AMM)"}),"\non Lux, similar in operation to ",(0,a.jsx)(n.a,{href:"https://uniswap.org/",children:"Uniswap"}),". It can be\nused to swap Ethereum and Lux assets and has fast settlement times and low\ntransaction fees. The Graph\u2019s hosted service provides a playground for deployed\nsubgraphs. The playground is an IDE-like environment based on\n",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphiql",children:"GraphiQL"})," where you can write sample\nqueries to fetch data supported by a subgraph. It is a valuable tool when\ngetting to know the queries that are supported by third-party subgraphs deployed\nby various projects. The Pangolin exchange subgraph can be accessed\n",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/subgraph/dasconnor/pangolin-dex?selected=playground",children:"here"}),".\nBelow is an image of the playground interface."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The Graph Playground",src:t(33138).Z+"",title:"The Graph Playground",width:"1473",height:"889"})}),"\n",(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/subgraph/dasconnor/pangolin-dex?selected=playground",children:"https://thegraph.com/legacy-explorer/subgraph/dasconnor/pangolin-dex?selected=playground"})]}),"\n",(0,a.jsx)(n.p,{children:"The playground consists of the 3 sections, the query section, the results\nsection, and the schema section. You can modify queries, click on the play\nbutton and have the returned data displayed in the middle section (results\nsection). The schema section enables you to go through the entities and their\nassociated fields to know what kind of queries are supported by that particular\nsubgraph. Below is an example query you can initiate on the Pangolin exchange\nsubgraph."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  tokens(first: 2) {\n    id\n    symbol\n    name\n    decimals\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The query above is asking for the first 2 tokens from the results of the\nPangolin exchange subgraph and it is interested in the fields - ",(0,a.jsx)(n.code,{children:"id"}),", ",(0,a.jsx)(n.code,{children:"symbol"}),",\n",(0,a.jsx)(n.code,{children:"name"}),", and ",(0,a.jsx)(n.code,{children:"decimals"}),". The returned result is shown below."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  "data": {\n    "tokens": [\n      {\n        "decimals": "18",\n        "id": "0x008e26068b3eb40b443d3ea88c1ff99b789c10f7",\n        "name": "Zero.Exchange Token",\n        "symbol": "ZERO"\n      },\n      {\n        "decimals": "18",\n        "id": "0x020ef96c76a225fc0151c191b2a15accc915b68c",\n        "name": "WOUF",\n        "symbol": "WOUF"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Using the schema, you can browse through the Pangolin API to discover other\nentities you are interested in. For example, you can construct a query to know\nthe daily volume on Pangolin and the number of transactions carried out on the\n",(0,a.jsx)(n.a,{href:"https://support.lux.network/en/articles/4587136-what-is-a-decentralized-exchange-dex",children:"DEX"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  pangolinDayDatas(first: 3, orderBy: date) {\n    date\n    txCount\n    dailyVolumeETH\n    dailyVolumeUSD\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The query above will request the data from the first 3 days and only the fields specified will be returned."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  "data": {\n    "pangolinDayDatas": [\n      {\n        "dailyVolumeETH": "0",\n        "dailyVolumeUSD": "0",\n        "date": 1612742400,\n        "txCount": "2"\n      },\n      {\n        "dailyVolumeETH": "52995.55027820444446352341877709734",\n        "dailyVolumeUSD": "1497153.144890008456466344638128839",\n        "date": 1612828800,\n        "txCount": "3603"\n      },\n      {\n        "dailyVolumeETH": "381001.9576775585402832922123431514",\n        "dailyVolumeUSD": "15686187.55247135303384368066876295",\n        "date": 1612915200,\n        "txCount": "12447"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The result shows that there was no volume on the first day but the volume and\nthe number of transactions increased steadily from the second day to the third\nday."}),"\n",(0,a.jsx)(n.p,{children:"More data can be gotten from this particular entity by constructing queries that\nmatch the fields supported. These fields can be identified from the schema as\nshown in the image below."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Pangolin DEX Schema",src:t(74709).Z+"",title:"Pangolin DEX Schema",width:"376",height:"502"})}),"\n",(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/subgraph/dasconnor/pangolin-dex?selected=playground",children:"https://thegraph.com/legacy-explorer/subgraph/dasconnor/pangolin-dex?selected=playground"})]}),"\n",(0,a.jsxs)(n.p,{children:["You can also interact with a deployed subgraph programmatically from your\nfrontend application. To do this, you will need a GraphQL client like\n",(0,a.jsx)(n.a,{href:"https://www.apollographql.com/docs/",children:"Apollo"})," that will act as a communication\nlayer between your application and The Graph. First, open up a terminal in your\nproject folder and install Apollo and GraphQL. You can use either\n",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/",children:"NPM"})," or ",(0,a.jsx)(n.a,{href:"https://yarnpkg.com/",children:"Yarn"})," to install both\nusing the commands below like so."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"npm install @apollo/client graphql"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"yarn add @apollo/client graphql"})}),"\n",(0,a.jsxs)(n.p,{children:["Then get the API URL from the subgraph you want to use. The API URL can be\ngotten from The Graph explorer page of the deployed subgraph. In the Pangolin\nexample which you have been working on, the API URL for HTTP queries is\n",(0,a.jsx)(n.a,{href:"https://api.thegraph.com/subgraphs/name/dasconnor/pangolin-dex",children:"https://api.thegraph.com/subgraphs/name/dasconnor/pangolin-dex"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Import Apollo client to your project\u2019s code, construct a query according to the\nschema of the subgraph you are querying and issue the query using your\ninstantiated Apollo client. A code snippet demonstrating this is shown below."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import { ApolloClient, InMemoryCache, gql } from \'@apollo/client\';\n\nconst APIURL = "https://api.thegraph.com/subgraphs/name/dasconnor/pangolin-dex";\n\nconst tokensQuery = `\n  query {\n    tokens (first: 5) {\n      id\n      symbol\n      name\n      decimals\n    }\n  }\n`\n\nconst client = new ApolloClient({\n  uri: APIURL,\n  cache: new InMemoryCache()\n});\n\nclient.query({\n  query: gql(tokensQuery)\n})\n.then(data => console.log("Subgraph data: ", data))\n.catch(err => { console.log("Error fetching data: ", err) });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For a full reference on how to use Apollo Client, kindly consult the official ",(0,a.jsx)(n.a,{href:"https://www.apollographql.com/docs/react/",children:"documentation"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"how-to-build-a-subgraph",children:"How to Build a Subgraph"}),"\n",(0,a.jsx)(n.p,{children:"In the previous section, you were shown how to integrate an already deployed\nsubgraph into your project. In the next two sections, you will go a step further\nto define your subgraph, build it and deploy it to the hosted service."}),"\n",(0,a.jsx)(n.p,{children:"Follow the instructions below to begin the process."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The first thing to do is to sign in to the ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/",children:"hosted\nservice"})," if you already have an\naccount. If you do not have an account, you will be required to create one\nusing your ",(0,a.jsx)(n.a,{href:"https://github.com/",children:"GitHub"})," profile."]}),"\n",(0,a.jsx)(n.li,{children:"Next, click on your GitHub profile picture at the top right-hand corner to\naccess the Dashboard menu item."}),"\n",(0,a.jsx)(n.li,{children:"Once on the Dashboard click on the Add Subgraph button."}),"\n",(0,a.jsx)(n.li,{children:"Next, on the Create a Subgraph page, input relevant details like your subgraph\nname, subtitle, description, GitHub URL, etc. then create the subgraph."}),"\n",(0,a.jsx)(n.li,{children:"You will be presented with a page containing instructions on the next steps.\nDo not worry about these as you will perform them in this section."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"New Subgraph Instructions",src:t(13860).Z+"",title:"New Subgraph Instructions",width:"1444",height:"581"})}),"\n",(0,a.jsxs)(n.p,{children:["The subgraph project you will build will be based on the governance token of the\nPangolin exchange\n",(0,a.jsx)(n.a,{href:"https://snowtrace.io/address/0x60781C2586D68229fde47564546784ab3fACA982/transactions",children:"PNG"}),".\nIt will be a simple project with a single entity - ",(0,a.jsx)(n.code,{children:"Transfer"}),", which will be\nused to track Transfer events of the token. At the end of building this project,\nyou will have hands-on experience of how the various pieces fit together in a\nGraph project."]}),"\n",(0,a.jsx)(n.p,{children:"First, you need to install Graph CLI as you will use it to interact with The\nGraph from your terminal. Install it using NPM or Yarn with the commands below."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"npm install -g @graphprotocol/graph-cli"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"yarn global add @graphprotocol/graph-cli"})}),"\n",(0,a.jsx)(n.p,{children:"Next, you will initialize a scaffold project using Graph CLI like so."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"graph init --product hosted-service <GITHUB_USER>/<SUBGRAPH NAME>"})}),"\n",(0,a.jsxs)(n.p,{children:["Replace the variables in the command above with your GitHub username and the\nname of the subgraph you created in the earlier steps. Note that if your\nsubgraph name contains spaces, it will be concatenated with dashes and will be\nin lowercase. So ",(0,a.jsx)(n.code,{children:"Pangolin Token"})," will become ",(0,a.jsx)(n.code,{children:"pangolin-token"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"You will be prompted in the terminal to answer some questions such as the\nsubgraph name, the directory to create the subgraph, the blockchain network,\netc. Do not forget to switch the network to Lux."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Subgraph Network",src:t(51138).Z+"",title:"Subgraph Network",width:"550",height:"551"})}),"\n",(0,a.jsxs)(n.p,{children:["In a typical workflow where you are building your own smart contracts for\nLux Contract Chain, you will supply your deployed smart contract address\nwhen prompted to do so in the terminal. The smart contract serves as the data\nsource for your subgraph. In our example, we will use the Pangolin token which\nis already deployed on Lux. Do note that if The Graph fails to\nautomatically detect your deployed smart contract address from the online block\nexplorer, you will be required to provide a path to the contract\u2019s Application\nBinary Interface (ABI) file. If it is a project you are building you can\ngenerate the ABI files from your Solidity code. If it is an external project,\nyou can download the source code from the project\u2019s GitHub repository and\ngenerate the ABI files locally. Alternatively, you can copy the ABI of the\ndeployed contract from ",(0,a.jsx)(n.a,{href:"https://snowtrace.io/",children:"Lux Contract Chain\nExplorer"})," into a file. However, this is not the\nrecommended approach as the version you find on the Contract Chain Explorer may\nnot be the latest, also you run the risk of erroneously copying a malicious ABI.\nIf you must copy the ABI from the explorer, make sure you get the contract\naddress from the project\u2019s documentation. For Pangolin token, you can find it\n",(0,a.jsx)(n.a,{href:"https://pangolin.exchange/tutorials/getting-started",children:"here"}),". Copy the Pangolin\ntoken ABI from the Contract Chain Explorer ",(0,a.jsx)(n.a,{href:"https://snowtrace.io/address/0x60781C2586D68229fde47564546784ab3fACA982/contracts",children:"code\ntab"}),",\nsave it in a file with the name png.json and provide the file path to the Graph\nCLI when asked if you run into issues with automatic detection from the contract\naddress. Provide the value png for the contract name when prompted by the CLI.\nThe Graph CLI will generate a scaffolding containing several files and the\nsupplied ABI. Below is what the generated file structure looks like."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"File Structure",src:t(68781).Z+"",title:"File Structure",width:"208",height:"369"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"subgraph.yaml"})," file is the main entry point to your subgraph project, it contains the subgraph manifest."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'specVersion: 0.0.2\nschema:\n  file: ./schema.graphql\ndataSources:\n  - kind: ethereum/contract\n    name: Png\n    network: lux\n    source:\n      address: "0x60781C2586D68229fde47564546784ab3fACA982"\n      abi: Png\n    mapping:\n      kind: ethereum/events\n      apiVersion: 0.0.4\n      language: wasm/assemblyscript\n      entities:\n        - Transfer\n      abis:\n        - name: Png\n          file: ./abis/Png.json\n      eventHandlers:\n        - event: Transfer(indexed address,indexed address,uint256)\n          handler: handleTransfer\n      file: ./src/mapping.ts\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"dataSources"})," field on the subgraph.yaml file specifies the smart contract\nof interest. The value of the ",(0,a.jsx)(n.code,{children:"abi"})," field under the ",(0,a.jsx)(n.code,{children:"source"})," field must match\nthe value of the ",(0,a.jsx)(n.code,{children:"name"})," field under ",(0,a.jsx)(n.code,{children:"abis"}),". The value under entities is the name\nof the GraphQL entity that you will create. The ",(0,a.jsx)(n.code,{children:"eventHandlers"})," field currently\ncontains one event and the associated function that will be triggered to handle\nit. This file was generated from the ABI file for the Pangolin token. Other\nevents exposed by the ABI have been removed for simplicity. The file\n",(0,a.jsx)(n.code,{children:"schema.graphql"})," contains The Graph entities and is referenced in the\n",(0,a.jsx)(n.code,{children:"subgrpah.yaml"})," file. Below is the content of the file."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Transfer @entity {\n  id: ID!\n  from: Bytes! # address\n  to: Bytes! # address\n  amount: BigInt!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The content contains one entity - ",(0,a.jsx)(n.code,{children:"Transfer"})," indicated by the ",(0,a.jsx)(n.code,{children:"@entity"}),"\ndirective. The fields that may up the entity are ",(0,a.jsx)(n.code,{children:"id"}),", ",(0,a.jsx)(n.code,{children:"from"}),", ",(0,a.jsx)(n.code,{children:"to"}),", ",(0,a.jsx)(n.code,{children:"address"}),".\nNotice that these fields closely mirror the event signature of the Transfer\nevent of the Pangolin token. The fields have their type specified and all are\nNON NULLABLE as indicated by the exclamation mark."]}),"\n",(0,a.jsxs)(n.p,{children:["The next important piece is the\n",(0,a.jsx)(n.a,{href:"https://www.assemblyscript.org/",children:"AssemblyScript"})," Mappings. AssemblyScript is\nused to transform data from the blockchain\u2019s events and GraphQL entities into a\nformat that can be loaded on The Graph Node. Before writing your event handler\nmapping for the ",(0,a.jsx)(n.code,{children:"Transfer"})," event in the ",(0,a.jsx)(n.code,{children:"mappings.ts"})," file under the ",(0,a.jsx)(n.code,{children:"src"}),"\nfolder, you will need to generate the AssemblyScript classes from your ABI and\n",(0,a.jsx)(n.code,{children:"schema.graphql"})," file. Run the command below to do so."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"graph codegen"})}),"\n",(0,a.jsx)(n.p,{children:"Whenever you make changes to your GraphQL schema or your subgraph manifest, you\nwill be required to regenerate the mappings using the command above. It is\nconsidered best practice to regenerate your mappings often as they can become a\nsource of errors if you forget to do so."}),"\n",(0,a.jsxs)(n.p,{children:["Back in the ",(0,a.jsx)(n.code,{children:"mappings.ts"})," file, you will import the generated classes from the\nPangolin token ABI and the GraphQL schema. Next, the ",(0,a.jsx)(n.code,{children:"handleTransfer"})," function\nwill take in a ",(0,a.jsx)(n.code,{children:"Transfer"})," event, parse its contents, and store it in the Graph\nNode. Remember that a blockchain event is always associated with a handler\nfunction that is triggered whenever the said event occurs. Below is the\n",(0,a.jsx)(n.code,{children:"mappings.ts"})," file for the Transfer event."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// Import the Transfer event class generated from the Png ABI\nimport { Transfer as TransferEvent } from "../generated/Png/Png"\n\n// Import the Transfer entity type generated from the GraphQL schema\nimport { Transfer } from "../generated/schema"\n\n// Transfer event handler\nexport function handleTransfer(event: TransferEvent): void {\n  // Create a Transfer entity, using the hexadecimal string representation\n  // of the transaction hash as the entity ID\n  let id = event.transaction.hash.toHex()\n  let transfer = new Transfer(id)\n\n  // Set properties on the entity, using the event parameters\n  transfer.from = event.params.from\n  transfer.to = event.params.to\n  transfer.amount = event.params.amount\n\n  // Save the entity to the store\n  transfer.save()\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can now build the subgraph project to make sure you do not have any errors.\nRun the build command like so."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"graph build"})}),"\n",(0,a.jsx)(n.p,{children:"If your subgraph builds successfully, you are ready for deployment."}),"\n",(0,a.jsx)(n.h3,{id:"how-to-deploy-a-subgraph",children:"How to Deploy a Subgraph"}),"\n",(0,a.jsx)(n.p,{children:"To deploy a subgraph you must authenticate with the hosted service using your\naccess token. Your access token can be seen from your project\u2019s dashboard. You\ncan authenticate by running the command below."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"graph auth --product hosted-service <ACCESS_TOKEN>"})}),"\n",(0,a.jsx)(n.p,{children:"The final step is to run the deployment command below and replace the variables with your details."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"graph deploy --product hosted-service <GITHUB_USER>/<SUBGRAPH NAME>"})}),"\n",(0,a.jsxs)(n.p,{children:["This initiates the deployment process and you should see your subgraph being\nuploaded to IPFS. After a while the upload is complete. You can now switch to\nyour project dashboard on the hosted service. Your subgraph will have a status\nof syncing as it indexes the event of interest from the genesis block of the\nblockchain. If you want indexing to start at a specific block, you can specify\nit in the ",(0,a.jsx)(n.code,{children:"startBlock"})," field under the ",(0,a.jsx)(n.code,{children:"source"})," field in your ",(0,a.jsx)(n.code,{children:"subgraph.yaml"}),"\nfile. For a full list of options for the subgraph manifest look at the official\n",(0,a.jsx)(n.a,{href:"https://thegraph.com/docs/developer/create-subgraph-hosted#the-subgraph-manifest",children:"documentation"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Syncing Parameters",src:t(15561).Z+"",title:"Syncing Parameters",width:"1458",height:"450"})}),"\n",(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://thegraph.com/legacy-explorer/subgraph/ofemeteng/pangolin-token",children:"https://thegraph.com/legacy-explorer/subgraph/ofemeteng/pangolin-token"})]}),"\n",(0,a.jsx)(n.p,{children:"Depending on the amount of data that is being indexed by the subgraph, the\nsyncing period may take longer. Once the subgraph has synced fully without\nerrors, you can query the supported entities through the playground or by\nintegrating the queries endpoint in your project using a framework like Apollo."}),"\n",(0,a.jsx)(n.p,{children:"You can try issuing the query below on your deployed Pangolin Token subgraph from the playground."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  transfers(first: 3) {\n    id\n    from\n    to\n    amount\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The results return the first 3 transfer events from the subgraph as expected."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  "data": {\n    "transfers": [\n      {\n        "amount": "46649696040618800000",\n        "from": "0xeed2db9b2d2645aaca044ecb397518ca6d9e74a5",\n        "id": "0x000296c30c325db75de48101737f5d54408af486ab021323225767701429e66e",\n        "to": "0xd7538cabbf8605bde1f4901b47b8d42c61de0367"\n      },\n      {\n        "amount": "1766396909474367721",\n        "from": "0xbb67987c040619842b0f8b0257bde63be842b27b",\n        "id": "0x000308522c9a2266f4ac73e13f02e7496decbad08286d52642ee768ff7ef343e",\n        "to": "0xd7538cabbf8605bde1f4901b47b8d42c61de0367"\n      },\n      {\n        "amount": "6826187345560538842",\n        "from": "0xa16381eae6285123c323a665d4d99a6bcfaac307",\n        "id": "0x0003aba174d1ad02e24d07122bb8bd66d194b640f79b19f3290885f2952b7b2b",\n        "to": "0x063b88d53d109c12ec21785c4e5e89bb71369432"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can find the full code for the Pangolin Token subgraph in this ",(0,a.jsx)(n.a,{href:"https://github.com/ofemeteng/pangolin-token-subgraph",children:"GitHub repository"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Congratulations on getting to the end of this tutorial. That was an extensive\ntour of The Graph and Lux ecosystems. In this tutorial, you were\nintroduced to the concepts underpinning The Graph protocol and how it is set to\nbring about a new era of open APIs through which developers can build on the\nwork of others in an open, decentralized, and permissionless manner. You were\nalso introduced to GraphQL, the query language that powers The Graph protocol.\nThe unique tweaks of The Graph protocol as relates to GraphQL were also\nhighlighted and it was shown that The Graph currently only supports the Query\ntype in the GraphQL specification. Next, you were introduced to the Lux\nblockchain, which was designed specifically to solve some of the scaling issues\ncurrently being experienced by other Layer 1 blockchain networks. Lux\narchitecture and design choices were highlighted. Even though Lux operates\nbased on a novel consensus algorithm, its Contract Chain which is one of 3\nchains that make up the Lux ecosystem is EVM compatible. This means that\ndevelopers from Ethereum and other EVM-based chains can use tools that they are\nalready familiar with. Lux support for Solidity also means that DApps\nbuilt for these chains can be deployed on Lux and immediately reap the\nbenefits associated with low transfer fees and increased throughput. You were\nalso shown how to use The Graph protocol to query data from Lux. The\nplayground provided by The Graph was used to interact with the Pangolin\ndecentralized exchange subgraph and you were also introduced to Apollo Client\nthrough which you can programmatically interact with subgraphs via your frontend\nprojects. Finally, you built your own subgraph from scratch and deployed it on\nthe hosted service by leveraging the governance token of Pangolin."}),"\n",(0,a.jsx)(n.p,{children:"At this point, you should be well equipped with the knowledge and tools you need\nto build awesome data-based projects using The Graph and Lux. Happy\nBUIDLing."})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11539:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image1-23a8ec1391973bb09f7b33794a2c75cd.png"},13770:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image2-3c5cb7f1f21926b05ae3631f453ed49d.png"},33138:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image3-99ae70aa0fb1fea238cda4f7b6862818.png"},74709:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image4-d52793babad6f619baa9256b89dd27c0.png"},13860:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image5-8764c2b7ab7401281451d959cd9e7878.png"},51138:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image6-ea61ddbd63add278b65a0175ef6f0278.png"},68781:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image7-de77908d16d75af74f143c7656a41c0a.png"},15561:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pangolin-token-subgraph-image8-06b2a4262aa25e7ffd243e4a6e735cde.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>i});var a=t(67294);const r={},o=a.createContext(r);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);