"use strict";(self.webpackChunklux_docs=self.webpackChunklux_docs||[]).push([[435],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(a),h=s,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function h(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9308:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),i=["components"],o={},l="Lux Native Tokens and ARC-20s",c={unversionedId:"specs/coreth-arc20s",id:"specs/coreth-arc20s",title:"Lux Native Tokens and ARC-20s",description:"What is an Lux Native Token?",source:"@site/docs/specs/coreth-arc20s.md",sourceDirName:"specs",slug:"/specs/coreth-arc20s",permalink:"/specs/coreth-arc20s",draft:!1,editUrl:"https://github.com/luxdefi/network-docs/edit/main/docs/specs/coreth-arc20s.md",tags:[],version:"current",frontMatter:{},sidebar:"specs",next:{title:"AVM Transaction Format",permalink:"/specs/avm-transaction-serialization"}},p={},d=[{value:"What is an Lux Native Token?",id:"what-is-an-lux-native-token",level:2},{value:"Why move an ANT from the X-Chain to the C-Chain?",id:"why-move-an-ant-from-the-x-chain-to-the-c-chain",level:2},{value:"Tokens on the C-Chain",id:"tokens-on-the-c-chain",level:2},{value:"LUX",id:"lux",level:3},{value:"ANTs",id:"ants",level:3},{value:"nativeAssetCall",id:"nativeassetcall",level:4},{value:"nativeAssetBalance",id:"nativeassetbalance",level:4},{value:"ARC-20s",id:"arc-20s",level:2},{value:"What is an ERC-20",id:"what-is-an-erc-20",level:3},{value:"From ANT to ARC-20",id:"from-ant-to-arc-20",level:3},{value:"Contract Balance / Total Supply",id:"contract-balance--total-supply",level:4},{value:"ARC-20 Deposits",id:"arc-20-deposits",level:4},{value:"ARC-20 Withdrawals",id:"arc-20-withdrawals",level:4}],u={toc:d};function h(e){var t=e.components,a=(0,s.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lux-native-tokens-and-arc-20s"},"Lux Native Tokens and ARC-20s"),(0,r.kt)("h2",{id:"what-is-an-lux-native-token"},"What is an Lux Native Token?"),(0,r.kt)("p",null,"An Lux Native Token (ANT) is a fixed-cap or variable-cap token created on the X-Chain. These tokens can be exchanged at lightning fast speeds on the X-Chain, which takes advantage of the superior performance of a DAG over a linear chain. In this document, Lux Native Tokens do not include non-fungible tokens (NFTs) created on the X-Chain."),(0,r.kt)("h2",{id:"why-move-an-ant-from-the-x-chain-to-the-c-chain"},"Why move an ANT from the X-Chain to the C-Chain?"),(0,r.kt)("p",null,"Smart contract functionality requires a total ordering of state transitions (transactions). As a result, ANTs must be moved to the C-Chain if they are to be used in smart contracts."),(0,r.kt)("h2",{id:"tokens-on-the-c-chain"},"Tokens on the C-Chain"),(0,r.kt)("h3",{id:"lux"},"LUX"),(0,r.kt)("p",null,"LUX plays the same role on the C-Chain that ETH does on the Ethereum Network. When you create or call a smart contract, you pay the transaction fee (gas cost) with LUX. You can transfer LUX between accounts and send LUX to a smart contract using native EVM tools and libraries."),(0,r.kt)("h3",{id:"ants"},"ANTs"),(0,r.kt)("p",null,"ANTs, however, have no counterpart within the EVM. Therefore, the C-Chain has some modifications to support holding ANT balances and transferring ANTs on the C-Chain."),(0,r.kt)("p",null,"The C-Chain keeps a mapping ","[","assetID -",">"," balance","]"," in each account's storage to support ANTs. These tokens can be exported back to the X-Chain, or they can be used on the C-Chain using ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetBalance"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetBalance")," are precompiled contracts released in Apricot Phase 2 that allow richer use of ANTs on the C-Chain."),(0,r.kt)("h4",{id:"nativeassetcall"},"nativeAssetCall"),(0,r.kt)("p",null,"An EVM Transaction is composed of the following fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"nonce"))," Scalar value equal to the number of transactions sent by the sender."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"gasPrice"))," Scalar value equal to the number of Wei (1 Wei = 10^-18 LUX) paid per unit of gas to execute this transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"gasLimit"))," Scalar value equal to the maximum amount of gas that should be used in executing this transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"to"))," The 20 byte address of the message call's recipient. If the transaction is creating a contract, ",(0,r.kt)("inlineCode",{parentName:"li"},"to")," is left empty."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"value"))," Scalar value of native asset (LUX), in Wei (1 Wei = 10^-18 LUX), to be transferred to the message call's recipient or in the case of a contract creation, as an endowment to the newly created contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"v, r, s"))," Values corresponding to the signature of the transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"data"))," Unlimited size byte array specifying the input data to a contract call or, if creating a contract, the EVM bytecode for the account initialization process.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," is a precompiled contract at address ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0100000000000000000000000000000000000002"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," allows users to atomically transfer a native asset to a given address and, optionally, make a contract call to that address. This is parallel to how a normal transaction can send value to an address and atomically call that address with some ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),"."),(0,r.kt)("p",null,"Note: the caller of ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," is forwarded to the ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," defined in the call. This means that when ",(0,r.kt)("inlineCode",{parentName:"p"},"Address A")," invokes a contract through ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall"),", the contract will pereceive the caller (or ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender"),") as ",(0,r.kt)("inlineCode",{parentName:"p"},"Address A"),". This enables the deposit logic that we use to create ARC-20 contracts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"nativeAssetCall(address addr, uint256 assetID, uint256 assetAmount, bytes memory callData) -> {ret: bytes memory}\n")),(0,r.kt)("p",null,"These arguments can be packed by ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encodePacked(...)")," in Solidity since there is only one argument with variadic length (",(0,r.kt)("inlineCode",{parentName:"p"},"callData"),"). The first three arguments are constant length, so the precompiled contract simply parses the call input as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"+-------------+---------------+--------------------------------+\n| address     : address       |                       20 bytes |\n+-------------+---------------+--------------------------------+\n| assetID     : uint256       |                       32 bytes |\n+-------------+---------------+--------------------------------+\n| assetAmount : uint256       |                       32 bytes |\n+-------------+---------------+--------------------------------+\n| callData    : bytes memory  |            len(callData) bytes |\n+-------------+---------------+--------------------------------+\n                              |       84 + len(callData) bytes |\n                              +--------------------------------+\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"For example, to send an ANT with an assetID of ",(0,r.kt)("inlineCode",{parentName:"p"},"2nzgmhZLuVq8jc7NNu2eahkKwoJcbFWXWJCxHBVWAJEZkhquoK")," from address ",(0,r.kt)("inlineCode",{parentName:"p"},"0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC")," to address ",(0,r.kt)("inlineCode",{parentName:"p"},"0xDd1749831fbF70d88AB7bB07ef7CD9c53D054a57"),", first convert the assetID to hex, ",(0,r.kt)("inlineCode",{parentName:"p"},"0xec21e629d1252b3540e9d2fcd174a63af081417ea6826612e96815463b8a41d7"),". Next concatenate the address which is receiving the ANT, assetID and assetAmount and POST the value as the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," param to the ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0100000000000000000000000000000000000002")," address using the ",(0,r.kt)("inlineCode",{parentName:"p"},"eth_sendTransaction")," RPC."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'curl --location --request POST \'https://api.lux.network:443/ext/bc/C/rpc\' \\\n--header \'Content-Type: application/json\' \\\n--data-raw \'{\n    "id": 1,\n    "jsonrpc": "2.0",\n    "method": "eth_sendTransaction",\n    "params": [\n        {\n            "to": "0x0100000000000000000000000000000000000002",\n            "from": "0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC",\n            "value": "",\n            "gas": "0x2DC6C0",\n            "gasPrice": "0x34630B8A00",\n            "data": "0xDd1749831fbF70d88AB7bB07ef7CD9c53D054a57ec21e629d1252b3540e9d2fcd174a63af081417ea6826612e96815463b8a41d7000000000000000000000000000000000000000000000000000000000000012c"\n        }\n    ]\n}\'\n{\n    "jsonrpc": "2.0",\n    "id": 1,\n    "result": "0x451ffb79936be1baba438b591781192cbc9659d1f3a693a7a434b4a93dda639f"\n}\n')),(0,r.kt)("h4",{id:"nativeassetbalance"},"nativeAssetBalance"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetBalance")," is a precompiled contract at address ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0100000000000000000000000000000000000001"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetBalance")," is the ANT equivalent of using ",(0,r.kt)("inlineCode",{parentName:"p"},"balance")," to get the LUX balance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"nativeAssetBalance(address addr, uint256 assetID) -> {balance: uint256}\n")),(0,r.kt)("p",null,"These arguments can be packed by ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encodePacked(...)")," in Solidity since all of the arguments have constant length."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"+-------------+---------------+-----------------+\n| address     : address       |        20 bytes |\n+-------------+---------------+-----------------+\n| assetID     : uint256       |        32 bytes |\n+-------------+---------------+-----------------+\n                              |        52 bytes |\n                              +-----------------+\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"For example, to get the balance of address ",(0,r.kt)("inlineCode",{parentName:"p"},"0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC")," and assetID ",(0,r.kt)("inlineCode",{parentName:"p"},"2nzgmhZLuVq8jc7NNu2eahkKwoJcbFWXWJCxHBVWAJEZkhquoK"),", first convert the assetID to hex, ",(0,r.kt)("inlineCode",{parentName:"p"},"0xec21e629d1252b3540e9d2fcd174a63af081417ea6826612e96815463b8a41d7"),". Next concatenate the address and assetID and POST the value as the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," param to the ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0100000000000000000000000000000000000001")," address using the ",(0,r.kt)("inlineCode",{parentName:"p"},"eth_call")," RPC."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'curl --location --request POST \'https://api.lux.network:443/ext/bc/C/rpc\' \\\n--header \'Content-Type: application/json\' \\\n--data-raw \'{\n    "id": 1,\n    "jsonrpc": "2.0",\n    "method": "eth_call",\n    "params": [\n        {\n            "to": "0x0100000000000000000000000000000000000001",\n            "data": "0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FCec21e629d1252b3540e9d2fcd174a63af081417ea6826612e96815463b8a41d7"\n        },\n        "latest"\n    ]\n}\'\n{\n    "jsonrpc": "2.0",\n    "id": 1,\n    "result": "0x000000000000000000000000000000000000000000000000000000000000012c"\n}\n')),(0,r.kt)("h2",{id:"arc-20s"},"ARC-20s"),(0,r.kt)("p",null,"An ARC-20 is an ERC-20 token that wraps an underlying Lux Native Token, similar to how WLUX wraps LUX."),(0,r.kt)("h3",{id:"what-is-an-erc-20"},"What is an ERC-20"),(0,r.kt)("p",null,"An ERC-20 is a standardized token type on Ethereum. It presents a standard set of functions and events that allow a smart contract to serve as a token on Ethereum. For a complete explanation, read the original proposal ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-20"},"here"),"."),(0,r.kt)("p",null,"ERC-20s expose the following interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"// Functions\nfunction name() public view returns (string)\nfunction symbol() public view returns (string)\nfunction decimals() public view returns (uint8)\nfunction totalSupply() public view returns (uint256)\nfunction balanceOf(address _owner) public view returns (uint256 balance)\nfunction transfer(address _to, uint256 _value) public returns (bool success)\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success)\nfunction approve(address _spender, uint256 _value) public returns (bool success)\nfunction allowance(address _owner, address _spender) public view returns (uint256 remaining)\n\n// Events\nevent Transfer(address indexed _from, address indexed _to, uint256 _value)\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value)\n")),(0,r.kt)("p",null,"An ERC-20 is implemented by a smart contract, meaning they maintain their own state. That is, if your account owns 5 of a given ERC-20, then the data that gives your account ownership is actually stored in that ERC-20's contract. By contrast, an ETH balance is kept in your own account's storage."),(0,r.kt)("h3",{id:"from-ant-to-arc-20"},"From ANT to ARC-20"),(0,r.kt)("p",null,'Unlike ERC-20s, Lux Native Tokens (ANTs) are stored directly on the account that owns them. ANTs can be "wrapped" in order to make them usable in smart contracts on the C-Chain. We call this wrapped asset an ARC-20. To do this, we add an ',(0,r.kt)("inlineCode",{parentName:"p"},"assetID")," field to a regular ERC-20 contract to represent the underlying asset that the ARC-20 wraps."),(0,r.kt)("p",null,"Additionally, the ARC-20 contract supports two additional functions: ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit"),". To implement this, ARC-20s need to use the precompiled contracts: ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetBalance"),"."),(0,r.kt)("h4",{id:"contract-balance--total-supply"},"Contract Balance / Total Supply"),(0,r.kt)("p",null,"ERC-20s typically have a total supply field, but this can mean different things in the context of a wrapped asset. The total supply could indicate the total supply of the non-wrapped asset on the entire platform or the amount of the asset in the wrapper contract."),(0,r.kt)("p",null,"For simplicity, we use total supply to indicate the total supply of the wrapped asset in the ARC-20 contract."),(0,r.kt)("h4",{id:"arc-20-deposits"},"ARC-20 Deposits"),(0,r.kt)("p",null,"In order to deposit funds into an ARC-20, we need to send the ARC-20 contract the deposit amount and then invoke the contract's deposit function so that the contract can acknowledge the deposit and update the caller's balance. This is similar to WETH (Wrapped ETH) on Ethereum. With WETH, this can be accomplished with a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," because that method allows the caller to both send ETH and invoke a smart contract atomically. With non-LUX ARC-20s, ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," allows the same functionality for ANTs on the C-Chain."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"nonce")),": 2"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"gasPrice")),": 225 gwei"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"gasLimit")),": 3000000"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"to")),": ",(0,r.kt)("inlineCode",{parentName:"li"},"0x0100000000000000000000000000000000000002")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"value")),": 0"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"v, r, s")),": ","[","Transaction Signature","]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"data")),': abi.encodePacked(arc20Address, assetID, assetAmount, abi.encodeWithSignature("deposit()"))')),(0,r.kt)("p",null,"This transfers ",(0,r.kt)("inlineCode",{parentName:"p"},"assetAmount")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"assetID")," to the address of the ARC-20 contract and then calls ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit()")," on the contract."),(0,r.kt)("p",null,"The deposit function uses the previous value of the total supply to calculate how much of ",(0,r.kt)("inlineCode",{parentName:"p"},"assetID")," it has received in the deposit. Because ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," propagates its caller to the contract being invoked, when deposit is called, the ARC-20 contract sees ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," as the original caller of ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall")," and can increment the balance on behalf of the correct address accordingly."),(0,r.kt)("p",null,"Note: the contract's balance of ",(0,r.kt)("inlineCode",{parentName:"p"},"assetID")," may become out of sync with the total supply if someone sends funds to the contract without calling ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit()"),". In this case, the next account that calls ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit()")," would receive credit for the previously sent funds."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"    function deposit() public {\n        uint256 updatedBalance = NativeAssets.assetBalance(address(this), _assetID);\n        uint256 depositAmount = updatedBalance - _totalSupply;\n        assert(depositAmount >= 0);\n\n        _balances[msg.sender] += depositAmount;\n        _totalSupply = updatedBalance;\n        emit Deposit(msg.sender, depositAmount);\n    }\n")),(0,r.kt)("h4",{id:"arc-20-withdrawals"},"ARC-20 Withdrawals"),(0,r.kt)("p",null,"When an ARC-20 contract receives a withdrawal request, it simply verifies that there's a sufficient account balance, updates the balance and total supply, and sends the funds to the withdrawer with ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeAssetCall"),". The ARC-20s withdraw function looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'    function withdraw(uint256 value) public {\n        require(_balances[msg.sender] >= value, "Insufficient funds for withdrawal");\n\n        _balances[msg.sender] -= value;\n        _totalSupply -= value;\n\n        NativeAssets.assetCall(msg.sender, _assetID, value, "");\n        emit Withdrawal(msg.sender, value);\n    }\n')))}h.isMDXComponent=!0}}]);