"use strict";(self.webpackChunklux_docs=self.webpackChunklux_docs||[]).push([[1263],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=l(n),p=s,f=h["".concat(c,".").concat(p)]||h[p]||d[p]||r;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9909:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return d}});var a=n(7462),s=n(3366),r=(n(7294),n(3905)),i=["components"],o={},c="Send an Asset on the X-Chain",l={unversionedId:"apis/luxjs/send-an-asset-on-the-x-chain",id:"apis/luxjs/send-an-asset-on-the-x-chain",title:"Send an Asset on the X-Chain",description:"This example sends an asset in the X-Chain to a single recipient. The first step in this process is to create an instance of Lux connected to our Lux Platform endpoint of choice.",source:"@site/docs/apis/luxjs/send-an-asset-on-the-x-chain.md",sourceDirName:"apis/luxjs",slug:"/apis/luxjs/send-an-asset-on-the-x-chain",permalink:"/apis/luxjs/send-an-asset-on-the-x-chain",draft:!1,editUrl:"https://github.com/luxdefi/network-docs/edit/main/docs/apis/luxjs/send-an-asset-on-the-x-chain.md",tags:[],version:"current",frontMatter:{},sidebar:"apis",previous:{title:"Manage X-Chain Keys",permalink:"/apis/luxjs/manage-x-chain-keys"},next:{title:"Generate a TxID using LuxJS",permalink:"/apis/luxjs/generate-a-txid-using-luxjs"}},u={},d=[{value:"Getting the UTXO Set",id:"getting-the-utxo-set",level:2},{value:"Spending the UTXOs",id:"spending-the-utxos",level:2},{value:"Get the status of the transaction",id:"get-the-status-of-the-transaction",level:2},{value:"Check the results",id:"check-the-results",level:2}],h={toc:d};function p(e){var t=e.components,n=(0,s.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"send-an-asset-on-the-x-chain"},"Send an Asset on the X-Chain"),(0,r.kt)("p",null,"This example sends an asset in the X-Chain to a single recipient. The first step in this process is to create an instance of Lux connected to our Lux Platform endpoint of choice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Lux, BinTools, Buffer, BN } from "lux"\n\nlet myNetworkID = 1 //default is 3, we want to override that for our local network\nlet myBlockchainID = "2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM" // The X-Chain blockchainID on this network\nlet lux = new lux.Lux(\n  "localhost",\n  9650,\n  "http",\n  myNetworkID,\n  myBlockchainID\n)\nlet xchain = lux.XChain() //returns a reference to the X-Chain used by LuxJS\n')),(0,r.kt)("p",null,"We\u2019re also assuming that the keystore contains a list of addresses used in this transaction."),(0,r.kt)("h2",{id:"getting-the-utxo-set"},"Getting the UTXO Set"),(0,r.kt)("p",null,"The X-Chain stores all available balances in a datastore called Unspent Transaction Outputs (UTXOs). A UTXO Set is the unique list of outputs produced by transactions, addresses that can spend those outputs, and other variables such as lockout times (a timestamp after which the output can be spent) and thresholds (how many signers are required to spend the output)."),(0,r.kt)("p",null,"For the case of this example, we\u2019re going to create a simple transaction that spends an amount of available coins and sends it to a single address without any restrictions. The management of the UTXOs will mostly be abstracted away."),(0,r.kt)("p",null,"However, we do need to get the UTXO Set for the addresses we\u2019re managing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let myAddresses = xchain.keyChain().getAddresses() //returns an array of addresses the KeyChain manages\nlet addressStrings = xchain.keyChain().getAddressStrings() //returns an array of addresses the KeyChain manages as strings\nlet utxos = (await xchain.getUTXOs(myAddresses)).utxos\n")),(0,r.kt)("h2",{id:"spending-the-utxos"},"Spending the UTXOs"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"buildBaseTx()")," helper function sends a single asset type. We have a particular assetID whose coins we want to send to a recipient address. This is an imaginary asset for this example which we believe to have 400 coins. Let\u2019s verify that we have the funds available for the transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'let assetid = "23wKfz3viWLmjWo2UZ7xWegjvnZFenGAVkouwQCeB9ubPXodG6" //avaSerialized string\nlet mybalance = utxos.getBalance(myAddresses, assetid) //returns 400 as a BN\n')),(0,r.kt)("p",null,"We have 400 coins! We\u2019re going to now send 100 of those coins to our friend\u2019s address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'let sendAmount = new BN(100) //amounts are in BN format\nlet friendsAddress = "X-lux1k26jvfdzyukms95puxcceyzsa3lzwf5ftt0fjk" // address format is Bech32\n\n//The below returns a UnsignedTx\n//Parameters sent are (in order of appearance):\n//   * The UTXO Set\n//   * The amount being sent as a BN\n//   * An array of addresses to send the funds\n//   * An array of addresses sending the funds\n//   * An array of addresses any leftover funds are sent\n//   * The AssetID of the funds being sent\nlet unsignedTx = await xchain.buildBaseTx(\n  utxos,\n  sendAmount,\n  [friendsAddress],\n  addressStrings,\n  addressStrings,\n  assetid\n)\nlet signedTx = unsignedTx.sign(myKeychain)\nlet txid = await xchain.issueTx(signedTx)\n')),(0,r.kt)("p",null,"And the transaction is sent!"),(0,r.kt)("h2",{id:"get-the-status-of-the-transaction"},"Get the status of the transaction"),(0,r.kt)("p",null,"Now that we sent the transaction to the network, it takes a few seconds to determine if the transaction has gone through. We can get an updated status on the transaction using the TxID through the X-Chain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// returns one of: "Accepted", "Processing", "Unknown", and "Rejected"\nlet status = await xchain.getTxStatus(txid)\n')),(0,r.kt)("p",null,'The statuses can be one of "Accepted", "Processing", "Unknown", and "Rejected":'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'"Accepted" indicates that the transaction has been accepted as valid by the network and executed'),(0,r.kt)("li",{parentName:"ul"},'"Processing" indicates that the transaction is being voted on.'),(0,r.kt)("li",{parentName:"ul"},'"Unknown" indicates that node knows nothing about the transaction, indicating the node doesn\u2019t have it'),(0,r.kt)("li",{parentName:"ul"},'"Rejected" indicates the node knows about the transaction, but it conflicted with an accepted transaction')),(0,r.kt)("h2",{id:"check-the-results"},"Check the results"),(0,r.kt)("p",null,'The transaction finally came back as "Accepted", now let\u2019s update the UTXOSet and verify that the transaction balance is as we expected.'),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: In a real network the balance isn\u2019t guaranteed to match this scenario. Transaction fees or additional spends may vary the balance. For the purpose of this example, we assume neither of those cases.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'let updatedUTXOs = await xchain.getUTXOs()\nlet newBalance = updatedUTXOs.getBalance(myAddresses, assetid)\nif (newBalance.toNumber() != mybalance.sub(sendAmount).toNumber()) {\n  throw Error("heyyy these should equal!")\n}\n')))}p.isMDXComponent=!0}}]);