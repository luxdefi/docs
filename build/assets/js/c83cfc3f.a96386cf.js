"use strict";(self.webpackChunklux_docs=self.webpackChunklux_docs||[]).push([[7910],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=l(n),d=s,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||i;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,r=new Array(i);r[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:s,r[1]=o;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7024:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return p}});var a=n(7462),s=n(3366),i=(n(7294),n(3905)),r=["components"],o={},c="Create an Asset on the X-Chain",l={unversionedId:"apis/luxjs/create-an-asset-on-the-x-chain",id:"apis/luxjs/create-an-asset-on-the-x-chain",title:"Create an Asset on the X-Chain",description:"This example creates an asset on the X-Chain and publishes it to the Lux platform. The first step in this process is to create an instance of LuxJS connected to our Lux platform endpoint of choice. In this example we're using the local network 12345 via Lux Network Runner. The code examples are written in typescript. The script is in full, in both typescript and javascript, after the individual steps. The whole example can be found here.",source:"@site/docs/apis/luxjs/create-an-asset-on-the-x-chain.md",sourceDirName:"apis/luxjs",slug:"/apis/luxjs/create-an-asset-on-the-x-chain",permalink:"/apis/luxjs/create-an-asset-on-the-x-chain",draft:!1,editUrl:"https://github.com/luxdefi/network-docs/edit/main/docs/apis/luxjs/create-an-asset-on-the-x-chain.md",tags:[],version:"current",frontMatter:{},sidebar:"apis",previous:{title:"API",permalink:"/apis/luxjs/api"},next:{title:"Manage X-Chain Keys",permalink:"/apis/luxjs/manage-x-chain-keys"}},u={},p=[{value:"Import the local network&#39;s pre-funded address",id:"import-the-local-networks-pre-funded-address",level:2},{value:"Prepare for the Mint Output",id:"prepare-for-the-mint-output",level:2},{value:"Describe the new asset",id:"describe-the-new-asset",level:2},{value:"Set up async/await",id:"set-up-asyncawait",level:2},{value:"Fetch the UTXO",id:"fetch-the-utxo",level:2},{value:"Creating the initial state",id:"creating-the-initial-state",level:2},{value:"Create the Mint Output",id:"create-the-mint-output",level:2},{value:"Creating the signed transaction",id:"creating-the-signed-transaction",level:2},{value:"Sign and issue the transaction",id:"sign-and-issue-the-transaction",level:2},{value:"Get the status of the transaction",id:"get-the-status-of-the-transaction",level:2},{value:"Identifying the newly created asset",id:"identifying-the-newly-created-asset",level:2}],h={toc:p};function d(e){var t=e.components,n=(0,s.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-an-asset-on-the-x-chain"},"Create an Asset on the X-Chain"),(0,i.kt)("p",null,"This example creates an asset on the X-Chain and publishes it to the Lux platform. The first step in this process is to create an instance of LuxJS connected to our Lux platform endpoint of choice. In this example we're using the local network ",(0,i.kt)("inlineCode",{parentName:"p"},"12345")," via ",(0,i.kt)("a",{parentName:"p",href:"/subnets/network-runner"},"Lux Network Runner"),". The code examples are written in typescript. The script is in full, in both typescript and javascript, after the individual steps. The whole example can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/luxdefi/luxjs/blob/master/examples/avm/buildCreateAssetTx.ts"},"here"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { Lux, BN, Buffer } from "lux"\nimport {\n  AVMAPI,\n  KeyChain,\n  UTXOSet,\n  UnsignedTx,\n  Tx,\n  InitialStates,\n  SECPMintOutput,\n  SECPTransferOutput,\n} from "lux/dist/apis/avm"\nimport {\n  PrivateKeyPrefix,\n  DefaultLocalGenesisPrivateKey,\n} from "lux/dist/utils"\n\nconst ip: string = "localhost"\nconst port: number = 9650\nconst protocol: string = "http"\nconst networkID: number = 12345 // Default is 1, we want to override that for our local network\nconst lux: Lux = new Lux(ip, port, protocol, networkID)\n')),(0,i.kt)("h2",{id:"import-the-local-networks-pre-funded-address"},"Import the local network's pre-funded address"),(0,i.kt)("p",null,"Next we get an instance of the X-Chain local keychain. The local network ",(0,i.kt)("inlineCode",{parentName:"p"},"12345")," has a pre-funded address which you can access with the private key ",(0,i.kt)("inlineCode",{parentName:"p"},"PrivateKey-ewoqjP7PxY4yr3iLTpLisriqt94hdyDFNgchSxGGztUrTXtNN")," which can be referenced from ",(0,i.kt)("inlineCode",{parentName:"p"},"${PrivateKeyPrefix}${DefaultLocalGenesisPrivateKey}"),". Lastly get the pre-funded address as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Buffer")," and as a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const xchain: AVMAPI = lux.XChain()\nconst xKeychain: KeyChain = xchain.keyChain()\nconst privKey: string = `${PrivateKeyPrefix}${DefaultLocalGenesisPrivateKey}`\nxKeychain.importKey(privKey)\nconst xAddresses: Buffer[] = xchain.keyChain().getAddresses()\nconst xAddressStrings: string[] = xchain.keyChain().getAddressStrings()\n")),(0,i.kt)("h2",{id:"prepare-for-the-mint-output"},"Prepare for the Mint Output"),(0,i.kt)("p",null,"Now we need to create an empty array for the ",(0,i.kt)("inlineCode",{parentName:"p"},"SECPMintOutput"),". We also need a ",(0,i.kt)("inlineCode",{parentName:"p"},"threshold")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"locktime")," for the outputs which we're going to create. Each X-Chain transaction can can contain a ",(0,i.kt)("inlineCode",{parentName:"p"},"memo")," field of up to 256 bytes of arbitrary data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const outputs: SECPMintOutput[] = []\nconst threshold: number = 1\nconst locktime: BN = new BN(0)\nconst memo: Buffer = Buffer.from(\n  "AVM utility method buildCreateAssetTx to create an ANT"\n)\n')),(0,i.kt)("h2",{id:"describe-the-new-asset"},"Describe the new asset"),(0,i.kt)("p",null,"The first step in creating a new asset using LuxJS is to determine the qualities of the asset. We will give the asset a name, a ticker symbol, as well as a denomination."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const name: string = "TestToken"\nconst symbol: string = "TEST"\nconst denomination: number = 3\n')),(0,i.kt)("h2",{id:"set-up-asyncawait"},"Set up async/await"),(0,i.kt)("p",null,"The remaining code will be encapsulated by this ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function so that we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," pattern."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const main = async (): Promise<any> => {}\nmain()\n")),(0,i.kt)("h2",{id:"fetch-the-utxo"},"Fetch the UTXO"),(0,i.kt)("p",null,"Pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"xAddressStrings")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"xchain.getUTXOs")," to fetch the UTXO."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const avmUTXOResponse: any = await xchain.getUTXOs(xAddressStrings)\nconst utxoSet: UTXOSet = avmUTXOResponse.utxos\n")),(0,i.kt)("h2",{id:"creating-the-initial-state"},"Creating the initial state"),(0,i.kt)("p",null,"We want to mint an asset with 507 units held by the managed key. This sets up the state that will result from the Create Asset transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Create outputs for the asset's initial state\nconst amount: BN = new BN(507)\nconst vcapSecpOutput: SECPTransferOutput = new SECPTransferOutput(\n  amount,\n  xAddresses,\n  locktime,\n  threshold\n)\nconst initialStates: InitialStates = new InitialStates()\n\n// Populate the initialStates with the outputs\ninitialStates.addOutput(vcapSecpOutput)\n")),(0,i.kt)("h2",{id:"create-the-mint-output"},"Create the Mint Output"),(0,i.kt)("p",null,"We also want to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"SECPMintOutput")," so that we can mint more of this asset later."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const secpMintOutput: SECPMintOutput = new SECPMintOutput(\n  xAddresses,\n  locktime,\n  threshold\n)\noutputs.push(secpMintOutput)\n")),(0,i.kt)("h2",{id:"creating-the-signed-transaction"},"Creating the signed transaction"),(0,i.kt)("p",null,"Now that we know what we want an asset to look like, we create a transaction to send to the network. There is an AVM helper function ",(0,i.kt)("inlineCode",{parentName:"p"},"buildCreateAssetTx()")," which does just that."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const unsignedTx: UnsignedTx = await xchain.buildCreateAssetTx(\n  utxoSet,\n  xAddressStrings,\n  xAddressStrings,\n  initialStates,\n  name,\n  symbol,\n  denomination,\n  outputs,\n  memo\n)\n")),(0,i.kt)("h2",{id:"sign-and-issue-the-transaction"},"Sign and issue the transaction"),(0,i.kt)("p",null,"Now let's sign the transaction and issue it to the Lux network. If successful it will return a ",(0,i.kt)("a",{parentName:"p",href:"http://support.lux.network/en/articles/4587395-what-is-cb58"},"CB58")," serialized string for the transaction ID."),(0,i.kt)("p",null,"Now that we have a signed transaction ready to send to the network, let\u2019s issue it!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const tx: Tx = unsignedTx.sign(xKeychain)\nconst txid: string = await xchain.issueTx(tx)\nconsole.log(`Success! TXID: ${txid}`)\n")),(0,i.kt)("h2",{id:"get-the-status-of-the-transaction"},"Get the status of the transaction"),(0,i.kt)("p",null,"Now that we sent the transaction to the network, it takes a few seconds to determine if the transaction has gone through. We can get an updated status on the transaction using the transaction ID through the AVM API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// returns one of: "Accepted", "Processing", "Unknown", and "Rejected"\nconst status: string = await xchain.getTxStatus(id)\n')),(0,i.kt)("p",null,'The statuses can be one of "Accepted", "Processing", "Unknown", and "Rejected":'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'"Accepted" indicates that the transaction has been accepted as valid by the network and executed'),(0,i.kt)("li",{parentName:"ul"},'"Processing" indicates that the transaction is being voted on.'),(0,i.kt)("li",{parentName:"ul"},'"Unknown" indicates that node knows nothing about the transaction, indicating the node doesn\u2019t have it'),(0,i.kt)("li",{parentName:"ul"},'"Rejected" indicates the node knows about the transaction, but it conflicted with an accepted transaction')),(0,i.kt)("h2",{id:"identifying-the-newly-created-asset"},"Identifying the newly created asset"),(0,i.kt)("p",null,'The X-Chain uses the transaction ID of the transaction which created the asset as the unique identifier for the asset. This unique identifier is henceforth known as the "AssetID" of the asset. When assets are traded around the X-Chain, they always reference the AssetID that they represent.'))}d.isMDXComponent=!0}}]);