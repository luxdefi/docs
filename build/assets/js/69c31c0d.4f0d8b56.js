"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9031],{95570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var o=t(85893),s=t(11151);const r={},i="LuxBridge.sol",d={id:"deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/LuxBridge.sol",title:"LuxBridge.sol",description:"",source:"@site/docs/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/LuxBridge.sol.md",sourceDirName:"deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge",slug:"/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/LuxBridge.sol",permalink:"/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/LuxBridge.sol",draft:!1,unlisted:!1,editUrl:"https://github.com/luxdefi/docs/edit/main/docs/deprecated/tutorials-contest/2022/erc20-as-subnet-gas-token/codes/contracts/Bridge/LuxBridge.sol.md",tags:[],version:"current",frontMatter:{}},a={},c=[];function l(e){const n={code:"code",h1:"h1",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"luxbridgesol",children:"LuxBridge.sol"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract LuxBridge {\n    address public admin;\n    /* Gets incremented with each `lock()`, indicates the transferCount\n    and prevents double processing the event */\n    uint public nonce;\n\n    /* Represents the ERC20 token */\n    IERC20 public luxToken;\n\n    /* Mapping to hold whether nonce is processed or not */\n    mapping(uint => bool) public processedNonces;\n\n    /* Allows us to indicate whether it is a `release()` or `lock()` when emitting an event */\n    enum Type {\n        Release,\n        Lock\n    }\n\n    /*\n        Event that is emitted with both `release()` and `lock()`\n        Relayer listens to events emitted by `lock()`\n        Potential frontend application may want to listen to events emitted by `release()`\n    */\n    event Transfer(\n        address from,\n        address to,\n        uint amount,\n        uint time,\n        uint nonce,\n        Type indexed transferType\n    );\n\n    /* Modifier to allow some functions to be only called by admin */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, "only admin");\n        _;\n    }\n\n    /* Constructor that sets admin as the sender and initializes the ERC20 token inside contract */\n    constructor(address _token) {\n        admin = msg.sender;\n        luxToken = IERC20(_token);\n    }\n\n    /* Function to allow setting a new admin */\n    function setAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /* Function that is called by the relayer to release some tokens after it is burned on the subnet */\n    function release(\n        address to,\n        uint amount,\n        uint subnetNonce\n    ) external onlyAdmin {\n        require(\n            processedNonces[subnetNonce] == false,\n            "nonce already processed"\n        );\n        processedNonces[subnetNonce] = true;\n\n        /* Bridge sends locked tokens to the `to` address therefore, releases the tokens */\n        luxToken.transfer(to, amount);\n\n        emit Transfer(\n            msg.sender,\n            to,\n            amount,\n            block.timestamp,\n            subnetNonce,\n            Type.Release\n        );\n    }\n\n    /*\n        Function that is called by the user to lock their tokens.\n        Relayer listens to the event emitted by this function and if the nonce is not processed,\n        it will call `mint()` of the SubnetBridge\n    */\n    function lock(address to, uint amount) external {\n        /* Send ERC20 tokens from msg.send (user) to bridge to lock the tokens */\n        /* Do not forget: sender should approve bridge address to do this */\n        luxToken.transferFrom(msg.sender, address(this), amount);\n\n        /* Event that is emitted for relayer to process */\n        emit Transfer(\n            msg.sender,\n            to,\n            amount,\n            block.timestamp,\n            nonce,\n            Type.Lock\n        );\n        /* Increment the nonce to prevent double counting */\n        nonce++;\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>i});var o=t(67294);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);