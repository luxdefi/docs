"use strict";(self.webpackChunklux_docs=self.webpackChunklux_docs||[]).push([[6132],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2890:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return r},metadata:function(){return p},toc:function(){return h}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),s=["components"],r={sidebar_position:2},l="Issuing API Calls",p={unversionedId:"apis/luxd/apis/issuing-api-calls",id:"apis/luxd/apis/issuing-api-calls",title:"Issuing API Calls",description:"This guide explains how to make calls to APIs exposed by Lux nodes.",source:"@site/docs/apis/luxd/apis/issuing-api-calls.md",sourceDirName:"apis/luxd/apis",slug:"/apis/luxd/apis/issuing-api-calls",permalink:"/apis/luxd/apis/issuing-api-calls",draft:!1,editUrl:"https://github.com/luxdefi/network-docs/edit/main/docs/apis/luxd/apis/issuing-api-calls.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"apis",previous:{title:"LuxGo APIs Overview",permalink:"/apis/luxd/apis/"},next:{title:"Platform Chain (P-Chain) API",permalink:"/apis/luxd/apis/p-chain"}},c={},h=[{value:"Endpoints",id:"endpoints",level:2},{value:"Base URL",id:"base-url",level:3},{value:"Endpoint Path",id:"endpoint-path",level:3},{value:"Primary Network and Subnet RPC calls",id:"primary-network-and-subnet-rpc-calls",level:2},{value:"Primary Network Endpoints",id:"primary-network-endpoints",level:3},{value:"C-Chain and Subnet EVM Endpoints",id:"c-chain-and-subnet-evm-endpoints",level:3},{value:"JSON-RPC EVM Endpoints",id:"json-rpc-evm-endpoints",level:4},{value:"Websocket EVM Endpoints",id:"websocket-evm-endpoints",level:4},{value:"Making a JSON RPC Request",id:"making-a-json-rpc-request",level:2},{value:"JSON RPC Success Response",id:"json-rpc-success-response",level:3},{value:"JSON RPC Error Response",id:"json-rpc-error-response",level:3},{value:"Other API Formats",id:"other-api-formats",level:2},{value:"Sending and Receiving Bytes",id:"sending-and-receiving-bytes",level:2}],u={toc:h};function d(e){var t=e.components,n=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"issuing-api-calls"},"Issuing API Calls"),(0,o.kt)("p",null,"This guide explains how to make calls to APIs exposed by Lux nodes."),(0,o.kt)("h2",{id:"endpoints"},"Endpoints"),(0,o.kt)("p",null,"An API call is made to an endpoint, which is a URL, made up of the base URI which is the address and the port of the node, and the path the particular endpoint the API call is on."),(0,o.kt)("h3",{id:"base-url"},"Base URL"),(0,o.kt)("p",null,"The base of the URL is always:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"[node-ip]:[http-port]")),(0,o.kt)("p",null,"where"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"node-ip")," is the IP address of the node the call is to."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"http-port")," is the port the node listens on for HTTP calls. This is specified by ",(0,o.kt)("a",{parentName:"li",href:"/nodes/maintain/luxd-config-flags#http-server"},"command-line argument")," ",(0,o.kt)("inlineCode",{parentName:"li"},"http-port")," (default value ",(0,o.kt)("inlineCode",{parentName:"li"},"9650"),").")),(0,o.kt)("p",null,"For example, if you're making RPC calls on the local node, the base URL might look like this: ",(0,o.kt)("inlineCode",{parentName:"p"},"127.0.0.1:9650"),"."),(0,o.kt)("p",null,"If you're making RPC calls to remote nodes, then the instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"127.0.0.1")," you should use the public IP of the server where the node is. Note that by default the node will only accept API calls on the local interface, so you will need to set up the ",(0,o.kt)("a",{parentName:"p",href:"/nodes/maintain/chain-config-flags#--http-host-string"},(0,o.kt)("inlineCode",{parentName:"a"},"http-host"))," config flag on the node. Also, you will need to make sure the firewall and/or security policy allows access to the ",(0,o.kt)("inlineCode",{parentName:"p"},"http-port")," from the internet."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"When setting up RPC access to a node, make sure you don't leave the ",(0,o.kt)("inlineCode",{parentName:"p"},"http-port")," accessible to everyone! There are malicious actors that scan for nodes that have unrestricted access to their RPC port and then use those nodes for spamming them with resource-intensive queries which can knock the node offline. Only allow access to your node's RPC port from known IP addresses!")),(0,o.kt)("h3",{id:"endpoint-path"},"Endpoint Path"),(0,o.kt)("p",null,"Each API\u2019s documentation specifies what endpoint path a user should make calls to in order to access the API\u2019s methods."),(0,o.kt)("p",null,"In general, they are formatted like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"/ext/[api-name]\n")),(0,o.kt)("p",null,"So for the Admin API, the endpoint path is ",(0,o.kt)("inlineCode",{parentName:"p"},"/ext/admin"),", for the Info API it is ",(0,o.kt)("inlineCode",{parentName:"p"},"/ext/info")," and so on. Note that some APIs have additional path components, most notably the chain RPC endpoints which includes the Subnet chain RPCs. We'll go over those in detail in the next section."),(0,o.kt)("p",null,"So, in combining the base URL and the endpoint path we get the complete URL for making RPC calls. For example, to make a local RPC call on the Info API, the full URL would be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"http://127.0.0.1:9650/ext/info\n")),(0,o.kt)("h2",{id:"primary-network-and-subnet-rpc-calls"},"Primary Network and Subnet RPC calls"),(0,o.kt)("p",null,"Besides the APIs that are local to the node, like Admin or Metrics APIs, nodes also expose endpoints for talking to particular chains that are either part of the Primary Network (the X, P and C chains), or part of any Subnets the node might be syncing or validating."),(0,o.kt)("p",null,"In general, chain endpoints are formatted as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"ext/bc/[blockchainID]\n")),(0,o.kt)("h3",{id:"primary-network-endpoints"},"Primary Network Endpoints"),(0,o.kt)("p",null,"The Primary Network consists of three chains: X, P and C chain. As those chains are present on every node, there are also convenient aliases defined that can be used instead of the full blockchainIDs. So, the endpoints look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"ext/bc/X\next/bc/P\next/bc/C\n")),(0,o.kt)("h3",{id:"c-chain-and-subnet-evm-endpoints"},"C-Chain and Subnet EVM Endpoints"),(0,o.kt)("p",null,"C-Chain and many subnets run a version of the EthereumVM (EVM). EVM exposes its own endpoints, which are also accessible on the node: JSON-RPC, and Websocket."),(0,o.kt)("h4",{id:"json-rpc-evm-endpoints"},"JSON-RPC EVM Endpoints"),(0,o.kt)("p",null,"To interact with C-Chain EVM via the JSON-RPC use the endpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"/ext/bc/C/rpc\n")),(0,o.kt)("p",null,"To interact with Subnet instances of the EVM via the JSON-RPC endpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"/ext/bc/[blockchainID]/rpc\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"blockchainID")," is the ID of the blockchain running the EVM. So for example, the RPC URL for the Swimmer Network (a Subnet that runs the Crabada game) running on a local node would be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"http://127.0.0.1/ext/bc/2K33xS9AyP9oCDiHYKVrHe7F54h2La5D8erpTChaAhdzeSu2RX/rpc\n")),(0,o.kt)("p",null,"Or for the WAGMI Subnet on the Fuji testnet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"http://127.0.0.1/ext/bc/2ebCneCbwthjQ1rYT41nhd7M76Hc6YmosMAQrTFhBq8qeqh6tt/rpc\n")),(0,o.kt)("h4",{id:"websocket-evm-endpoints"},"Websocket EVM Endpoints"),(0,o.kt)("p",null,"To interact with C-Chain via the websocket endpoint, use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"/ext/bc/C/ws\n")),(0,o.kt)("p",null,"To interact with other instances of the EVM via the websocket endpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"/ext/bc/blockchainID/ws\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"blockchainID")," is the ID of the blockchain running the EVM. For example, to interact with the C-Chain's Ethereum APIs via websocket on localhost you can use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"ws://127.0.0.1:9650/ext/bc/C/ws\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"When using the ",(0,o.kt)("a",{parentName:"p",href:"/apis/luxd/public-api-server"},"Public API")," or another host that supports HTTPS, use ",(0,o.kt)("inlineCode",{parentName:"p"},"https://")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"wss://")," instad of ",(0,o.kt)("inlineCode",{parentName:"p"},"http://")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"ws://"),"."),(0,o.kt)("p",{parentName:"admonition"},"Also, note that the ",(0,o.kt)("a",{parentName:"p",href:"/apis/luxd/public-api-server#supported-apis"},"public api")," only supports C-Chain websocket API calls for API methods that don't exist on the C-Chain's HTTP API.")),(0,o.kt)("h2",{id:"making-a-json-rpc-request"},"Making a JSON RPC Request"),(0,o.kt)("p",null,"Most of the built-in APIs use the ",(0,o.kt)("a",{parentName:"p",href:"https://www.jsonrpc.org/specification"},"JSON RPC 2.0")," format to describe their requests and responses. Such APIs include the Platform API and the X-Chain API."),(0,o.kt)("p",null,"Suppose we want to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"getTxStatus")," method of the ",(0,o.kt)("a",{parentName:"p",href:"/apis/luxd/apis/x-chain"},"X-Chain API"),". The X-Chain API documentation tells us that the endpoint for this API is ",(0,o.kt)("inlineCode",{parentName:"p"},"/ext/bc/X"),"."),(0,o.kt)("p",null,"That means that the endpoint we send our API call to is:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"[node-ip]:[http-port]/ext/bc/X")),(0,o.kt)("p",null,"The X-Chain API documentation tells us that the signature of ",(0,o.kt)("inlineCode",{parentName:"p"},"getTxStatus")," is:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/apis/luxd/apis/x-chain#avmgettxstatus"},(0,o.kt)("inlineCode",{parentName:"a"},"avm.getTxStatus")),(0,o.kt)("inlineCode",{parentName:"p"},"(txID:bytes) -> (status:string)")),(0,o.kt)("p",null,"where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Argument ",(0,o.kt)("inlineCode",{parentName:"li"},"txID")," is the ID of the transaction we\u2019re getting the status of."),(0,o.kt)("li",{parentName:"ul"},"Returned value ",(0,o.kt)("inlineCode",{parentName:"li"},"status")," is the status of the transaction in question.")),(0,o.kt)("p",null,"To call this method, then:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},'curl -X POST --data \'{\n    "jsonrpc":"2.0",\n    "id"     :4,\n    "method" :"avm.getTxStatus",\n    "params" :{\n        "txID":"2QouvFWUbjuySRxeX5xMbNCuAaKWfbk5FeEa2JmoF85RKLk2dD"\n    }\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/X\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"jsonrpc")," specifies the version of the JSON RPC protocol. (In practice is always 2.0)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"method")," specifies the service (",(0,o.kt)("inlineCode",{parentName:"li"},"avm"),") and method (",(0,o.kt)("inlineCode",{parentName:"li"},"getTxStatus"),") that we want to invoke."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"params")," specifies the arguments to the method."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id")," is the ID of this request. Request IDs should be unique.")),(0,o.kt)("p",null,"That\u2019s it!"),(0,o.kt)("h3",{id:"json-rpc-success-response"},"JSON RPC Success Response"),(0,o.kt)("p",null,"If the call is successful, the response will look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "jsonrpc": "2.0",\n  "result": {\n    "Status": "Accepted"\n  },\n  "id": 1\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id")," is the ID of the request that this response corresponds to."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"result")," is the returned values of ",(0,o.kt)("inlineCode",{parentName:"li"},"getTxStatus"),".")),(0,o.kt)("h3",{id:"json-rpc-error-response"},"JSON RPC Error Response"),(0,o.kt)("p",null,"If the API method invoked returns an error then the response will have a field ",(0,o.kt)("inlineCode",{parentName:"p"},"error")," in place of ",(0,o.kt)("inlineCode",{parentName:"p"},"result"),". Additionally, there is an extra field, ",(0,o.kt)("inlineCode",{parentName:"p"},"data"),", which holds additional information about the error that occurred."),(0,o.kt)("p",null,"Such a response would look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "jsonrpc": "2.0",\n    "error": {\n        "code": -32600,\n        "message": "[Some error message here]",\n        "data": [Object with additional information about the error]\n    },\n    "id": 1\n}\n')),(0,o.kt)("h2",{id:"other-api-formats"},"Other API Formats"),(0,o.kt)("p",null,"Some APIs may use a standard other than JSON RPC 2.0 to format their requests and responses. Such extension should specify how to make calls and parse responses to them in their documentation."),(0,o.kt)("h2",{id:"sending-and-receiving-bytes"},"Sending and Receiving Bytes"),(0,o.kt)("p",null,"Unless otherwise noted, when bytes are sent in an API call/response, they are in hex representation. However, Transaction IDs (txIDs), chainIDs, and subnetIDs are in ",(0,o.kt)("a",{parentName:"p",href:"https://support.lux.network/en/articles/4587395-what-is-cb58"},"CB58")," representation, a base-58 encoding with a checksum."))}d.isMDXComponent=!0}}]);