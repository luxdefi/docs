"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1608],{333:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(85893),o=n(11151);const r={},s="Introduction",i={id:"deprecated/tutorials-contest/2021/hardhat-fork/README",title:"Introduction",description:"These tutorials were published as a snapshot of when they were written,",source:"@site/docs/deprecated/tutorials-contest/2021/hardhat-fork/README.md",sourceDirName:"deprecated/tutorials-contest/2021/hardhat-fork",slug:"/deprecated/tutorials-contest/2021/hardhat-fork/",permalink:"/deprecated/tutorials-contest/2021/hardhat-fork/",draft:!1,unlisted:!1,editUrl:"https://github.com/luxdefi/docs/edit/master/docs/deprecated/tutorials-contest/2021/hardhat-fork/README.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Hardhat ?",id:"hardhat-",level:2},{value:"What Is the &#39;Fork&#39; Functionality ?",id:"what-is-the-fork-functionality-",level:2},{value:"Step by Step Explanation",id:"step-by-step-explanation",level:2},{value:"Smart Contract Overview",id:"smart-contract-overview",level:3},{value:"Hardhat Configuration",id:"hardhat-configuration",level:3},{value:"Tests Overview",id:"tests-overview",level:3},{value:"Bonus",id:"bonus",level:2},{value:"Time Travel",id:"time-travel",level:3},{value:"Impersonation",id:"impersonation",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Additional Links",id:"additional-links",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.p,{children:"These tutorials were published as a snapshot of when they were written,\nand may contain out-of-date-information.\nFor up-to-date information, please reach out to the owners of these\nprojects."})}),"\n",(0,a.jsxs)(t.p,{children:["In this tutorial we will cover the use of Hardhat, a powerful EVM development\ntool, together with Lux. More specifically, we will cover how to configure\nit to work with Lux C-Chain and how to use the Hardhat ",(0,a.jsx)(t.code,{children:"fork"})," mechanism to\ntest your DeFi dApps."]}),"\n",(0,a.jsx)(t.h2,{id:"hardhat-",children:"Hardhat ?"}),"\n",(0,a.jsxs)(t.p,{children:["Hardhat is an ",(0,a.jsx)(t.strong,{children:"Ethereum development environment for professionals"}),". It was\ndeveloped for Ethereum, but since lots of other blockchains reuse the EVM you\ncan apply Hardhat on those as well !"]}),"\n",(0,a.jsx)(t.p,{children:"In short, it helps you in all the important steps of smart contract development.\nFrom compiling, deploying, and testing your Solidity code. It has even a\nfunctionality to let you use 'console.log' in your smart contract's code!"}),"\n",(0,a.jsx)(t.p,{children:"It's not the purpose of this tutorial to go over all those functionalities\n(maybe in another tutorial, why not :) ), so here is a few links if you want to\nknow more about it:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://hardhat.org/getting-started",children:"Getting started"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://github.com/nomiclabs/hardhat",children:"Hardhat"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"what-is-the-fork-functionality-",children:"What Is the 'Fork' Functionality ?"}),"\n",(0,a.jsx)(t.p,{children:"So let's get back to the core of this tutorial : Hardhat fork mechanism."}),"\n",(0,a.jsx)(t.p,{children:"In order to make you realize the importance of this functionality, let me give you an example:"}),"\n",(0,a.jsxs)(t.p,{children:["Let's say you have a simple contract ",(0,a.jsx)(t.code,{children:"Swapper.sol"}),". It has a function ",(0,a.jsx)(t.code,{children:"swap"}),"\nthat once called with the appropriate parameters will swap for you some Wlux\ntokens into another ERC20 tokens listed on a DEX. For the sake of this tutorial\nwe will use ",(0,a.jsx)(t.a,{href:"https://pangolin.exchange/",children:"Pangolin"})]}),"\n",(0,a.jsx)(t.p,{children:"The flow of it would be:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Your send a call to Swapper's swap function"}),"\n",(0,a.jsxs)(t.li,{children:["Swapper use Pangolin's router ",(0,a.jsx)(t.code,{children:"swapExactTokensForTokens"})," function, it will\nfind the appropriate Pair contract address to call"]}),"\n",(0,a.jsx)(t.li,{children:"Pangolin's router call a Pair contract to make the swap"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Notice how it requires calls to external contracts."}),"\n",(0,a.jsxs)(t.p,{children:["If you want to test your Swapper ",(0,a.jsx)(t.code,{children:"swap"})," function you then need to set up in your test environment :"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"2 ERC20 contracts"}),"\n",(0,a.jsx)(t.li,{children:"Pangolin Factory"}),"\n",(0,a.jsx)(t.li,{children:"Pangolin router's contract"}),"\n",(0,a.jsx)(t.li,{children:"A Pair contract (PGL) using your 2 previously created ERC20."}),"\n",(0,a.jsx)(t.li,{children:"And all this with the appropriate constructor parameters, linking all this\ntogether. Doable but it'll require some time to set up all this properly."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So, what if I told you that we could avoid all of this and jump directly to the\nstep where you create tests for your smart contracts."}),"\n",(0,a.jsx)(t.p,{children:"That's where 'Hardhat fork' is coming in handy."}),"\n",(0,a.jsx)(t.p,{children:"With this you can simply make a copy of the state of an EVM chain (in our case\nthe C-Chain) and use it directly in your tests ! With all contract, addresses\nbalance available for you to use."}),"\n",(0,a.jsx)(t.p,{children:"So in our case we would not have to deploy all the relevant Pangolin's contract,\nwe could just use the one deployed on the Mainnet and test your smart contract\nwithout much hassle."}),"\n",(0,a.jsx)(t.h2,{id:"step-by-step-explanation",children:"Step by Step Explanation"}),"\n",(0,a.jsx)(t.h3,{id:"smart-contract-overview",children:"Smart Contract Overview"}),"\n",(0,a.jsx)(t.p,{children:"So first let's get over quickly the solidity code that we will use:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IRouter {\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint value) external;\n\n    function approve(address to, uint value) external returns (bool);\n\n}\n\n/**\n* I would not recommend you to use this code as it is. It is really simple and stripped of some basic security checks.\n*/\ncontract Swapper {\n\n    address private wlux; // Address of the ERC20 Wrapped Lux\n    address private router; // Address of the 'Uniswap-like' router contract\n\n    constructor(address _wlux_address, address _router){\n        wlux = _wlux_address;\n        router = _router;\n    }\n\n    /**\n    * This function will perform a swap on Pangolin. The pair must be a WLUX-ERC20 pair.\n    * @param amountOutMin Minimum amount of token that we want to get after our swap.\n    * @param path Array of tokens' address\n    * @param pair Address of the liquidity pair we will use in this swap\n    * @param deadline Not relevant for lux, just pass timestamp that is in the future\n    */\n    function swap(uint256 amountOutMin, address[] calldata path, address pair, uint256 amountIn, uint256 deadline) external {\n        // We transfer the wlux from the user (msg.sender) to this contract.\n        IERC20(wlux).transferFrom(msg.sender, address(this), amountIn);\n        // We approve the router as a spender for our Wlux.\n        IERC20(wlux).approve(router, amountIn);\n        // We do te swap using the router.\n        IRouter(router).swapExactTokensForTokens(amountIn, amountOutMin, path, msg.sender, deadline);\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"hardhat-configuration",children:"Hardhat Configuration"}),"\n",(0,a.jsx)(t.p,{children:"As you can see we use some external contract (Pangolin router). Meaning that if\nyou want to test this code... you'll have to mock/recreate this router and all\nthe contracts that this router use ... Kinda annoying right ?"}),"\n",(0,a.jsx)(t.p,{children:"Thanks to Hardhat, we can make our life easier and skip it altogether."}),"\n",(0,a.jsxs)(t.p,{children:["First we need to configure Hardhat. If you look in ",(0,a.jsx)(t.code,{children:"hardhat.config.ts"})," you'll see this :"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'const config: HardhatUserConfig = {\n    defaultNetwork: "hardhat",\n    solidity: "0.8.4",\n    networks: {\n        hardhat: {\n            chainId: 43114,\n            gasPrice: 225000000000,\n            forking: {\n                url: "https://api.lux.network/ext/bc/C/rpc",\n                enabled: true,\n            },\n        },\n        testnet: {\n            chainId: 43113,\n            gasPrice: 225000000000,\n            url: "https://api.lux-test.network/ext/bc/C/rpc",\n            accounts: [\n                PK_TEST\n            ]\n        }\n    },\n    typechain: {\n        outDir: "typechain",\n        target: "ethers-v5",\n    },\n};\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The most interesting portion of code here is the ",(0,a.jsx)(t.code,{children:"network"})," part. That's where\nyou configure networks that you want to use with your project. As you can see\nabove we have defined two networks for this tutorial:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"hardhat"}),", which is also the ",(0,a.jsx)(t.code,{children:"defaultNetwork"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"testnet"}),", which is pointing to Testnet."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Note that you can put multiple network definition, one of it is considered as\nthe 'default' one. Meaning that when you are using ",(0,a.jsx)(t.code,{children:"npx hardhat test"}),", it'll use\nthe default network. If you want to run the test on another network than the\ndefault, you can use this variation of the command : ",(0,a.jsx)(t.code,{children:"npx hardhat test --network testnet"})]}),"\n",(0,a.jsxs)(t.p,{children:["Now let's focus on the ",(0,a.jsx)(t.code,{children:"hardhat"})," one ."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'hardhat: {\n    chainId: 43114,\n        gasPrice\n:\n    225000000000,\n        forking\n:\n    {\n        url: "https://api.lux.network/ext/bc/C/rpc",\n            enabled\n    :\n        true,\n            blockNumber\n    :\n        2975762\n    }\n,\n}\n,\n'})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"chainId"})," is set with to the Mainnet value, as seen\n",(0,a.jsx)(t.a,{href:"https://docs.lux.network/build/apis/luxd/apis/c-chain",children:"here"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"gasPrice"})," is a dynamic value on Lux's C-Chain (see this\n",(0,a.jsx)(t.a,{href:"https://medium.com/luxlux/apricot-phase-three-c-chain-dynamic-fees-432d32d67b60",children:"post"}),"\nfor more information). For test purposes we can use a fixed value (225 nLux)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"forking"})," is where you configure the parameter of the fork.","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"url"})," here we see that we point to the Ava labs API endpoint This could be\nyour local node, as long as it is running as full archive node. Hardhat\nwill take care of getting the state of the C-Chain from this node and start\na local development network on which you'll be able to deploy and test\nyour code."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"blockNumber"})," Specify at which block Hardhat will create a fork. It is\noptional so if you don't set it, the default behaviour would be to fork\nthe C-Chain at the latest known block. Now since you want to be able to run\nyour tests in a deterministic manner, I recommend you to specify a\nspecific block number."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["If you want to see all configurations options, please go check\nthe ",(0,a.jsx)(t.a,{href:"https://hardhat.org/hardhat-network/reference/",children:"official documentation"})," for this feature."]}),"\n",(0,a.jsx)(t.h3,{id:"tests-overview",children:"Tests Overview"}),"\n",(0,a.jsx)(t.p,{children:"So we went over the Solidity code, the Hardhat configuration. Now let's have a\nlook at how to create a test using Hardhat."}),"\n",(0,a.jsx)(t.p,{children:"Now let's have a look at the test code."}),"\n",(0,a.jsx)(t.p,{children:"Testing with Hardhat is fairly simple, lots of things are abstracted away."}),"\n",(0,a.jsx)(t.p,{children:"Let's first have a first look at the test I've written for our Swapper contract,\nno worries we will dissect it a bit later."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { ethers } from "hardhat";\nimport * as dotenv from "dotenv";\nimport { SignerWithAddress } from "hardhat-deploy-ethers/src/signers";\nimport { BigNumber } from "ethers";\nimport { Swapper, IWLUX } from "../typechain";\n\ndotenv.config();\n\nconst LUX_NODE_URL: string = process.env.LUX_MAINNET_URL as string;\nconst WLUX_ADDRESS: string = process.env.WLUX_ADDRESS as string;\nconst PNG_ADDRESS = "0x60781C2586D68229fde47564546784ab3fACA982"\n\ndescribe("Swappity swap", function () {\n\n    let swapper: Swapper;\n    let account1: SignerWithAddress;\n\n    beforeEach(async function () {\n        await ethers.provider.send(\n            "hardhat_reset",\n            [\n                {\n                    forking: {\n                        jsonRpcUrl: LUX_NODE_URL,\n                        blockNumber: 2975762,\n                    },\n                },\n            ],\n        );\n\n        let accounts = await ethers.getSigners()\n\n        // @ts-ignore\n        account1 = accounts[0]\n\n        // Here we get the factory for our Swapper contrat and we deploy it on the forked network\n        const swapperFactory = await ethers.getContractFactory("Swapper")\n        swapper = await swapperFactory.deploy(process.env.WLUX_ADDRES as string, "0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106");\n    });\n\n    it("should swap wlux for png", async function () {\n\n        // We get an instance of the wlux contract\n        const wluxTokenContract = await ethers.getContractAt("IWLUX", WLUX_ADDRESS)\n        // @ts-ignore\n        const pngTokenContract = await ethers.getContractAt("IWLUX", PNG_ADDRESS)\n        //makes sure owner has enough WLUX balance\n        if ((await wluxTokenContract.balanceOf(account1.address)).lt("1000000000000000000000")) {\n            await wluxTokenContract.deposit({\n                value: BigNumber.from("1000000000000000000000")\n                    .sub(await wluxTokenContract.balanceOf(account1.address))\n            })\n        }\n\n        // We tell Wlux contract that we are cool with Swapper contract using our Wlux on our behalve\n        await wluxTokenContract.approve(swapper.address, ethers.constants.MaxUint256)\n\n        // Check balance before the swap\n        const wluxBalanceBefore = await wluxTokenContract.balanceOf(account1.address);\n        const pngBalanceBefore = await pngTokenContract.balanceOf(account1.address)\n        expect(wluxBalanceBefore).eq("1000000000000000000000");\n        expect(pngBalanceBefore).eq(0)\n\n        // We call Swapper contract to make a swap from Wlux to Png. I chose some weird values for the swap cause it\'s just for the sack of this tutorial.\n        await swapper.swap(100, [WLUX_ADDRESS, PNG_ADDRESS], "0xd7538cABBf8605BdE1f4901B47B8D42c61DE0367", 1000000000, 1807909162115)\n        // Check balance after\n\n        const wluxBalanceAfter = await wluxTokenContract.balanceOf(account1.address);\n        const pngBalanceAfter = await pngTokenContract.balanceOf(account1.address)\n\n        // Since we have done the swap, we expect the balance to be slightly different now. Less Wlux and more Png.\n        expect(wluxBalanceBefore).lt(wluxBalanceAfter);\n        expect(pngBalanceBefore).gt(pngBalanceAfter);\n    });\n});\n\n'})}),"\n",(0,a.jsx)(t.p,{children:"First we have all the imports."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { ethers } from "hardhat";\nimport * as dotenv from "dotenv";\nimport { SignerWithAddress } from "hardhat-deploy-ethers/src/signers";\nimport { BigNumber } from "ethers";\nimport { Swapper, IWLUX } from "../typechain";\n\ndotenv.config();\n'})}),"\n",(0,a.jsxs)(t.p,{children:["I won't go over in details about those, just notice that we use ",(0,a.jsx)(t.code,{children:"typechain"}),",\nwhich is a tool that generate automatically typescript bindings for your\nsolidity contracts. Basically it means that, when we instantiate an object\ncorresponding to a Solidity contract, we will have full typings and\nauto-completion. It saves you a lot of time and help you write better and safer\ncode. (I can't emphasize enough how much I love Typescript)"]}),"\n",(0,a.jsxs)(t.p,{children:["In the snippet below we can see the ",(0,a.jsx)(t.code,{children:"beforeEach"})," function (it is a\n",(0,a.jsx)(t.a,{href:"https://mochajs.org/#hooks",children:"hook"})," actually) that will run before each test case\nwe write in this file."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'describe("Swappity swap", function () {\n\n    let swapper: Swapper;\n    let account1: SignerWithAddress;\n\n    beforeEach(async function () {\n        await ethers.provider.send(\n            "hardhat_reset",\n            [\n                {\n                    forking: {\n                        jsonRpcUrl: LUX_NODE_URL,\n                        blockNumber: 2975762,\n                    },\n                },\n            ],\n        );\n\n        let accounts = await ethers.getSigners()\n\n        account1 = accounts[0]\n\n        // Here we get the factory for our Swapper contrat and we deploy it on the forked network\n        const swapperFactory = await ethers.getContractFactory("Swapper")\n        swapper = await swapperFactory.deploy(process.env.WLUX_ADDRES as string, "0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106");\n    });\n...\n'})}),"\n",(0,a.jsx)(t.p,{children:"Couple of things to note here :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:'await ethers.provider.send( "hardhat_reset", ...'})," It will reset the state of\nyour C-Chain fork. Meaning that each one of your test will run on a clean\ninstance."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"let accounts = await ethers.getSigners()"})," Ethers provides us a way to get\naccess to some ``Signers`. Which is a way to represent C-Chain account that we\ncan use in our tests."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:'const swapperFactory = await ethers.getContractFactory("Swapper")'})," We get\nhere via Ethers a ContractFactory that is an abstraction used to deploy smart\ncontracts."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:'swapper = await swapperFactory.deploy(process.env.WLUX_ADDRES as string, "0x....");'})," Here we use the factory to actually deploy the contract on the\nhardhat network, which is a forked version of C-Chain Mainnet ! The resulting\n",(0,a.jsx)(t.code,{children:"swapper"})," is an object (fully typed thanks to typechain) that represent the\n",(0,a.jsx)(t.code,{children:"Swapper"})," contract, and on which you will be able to call functions, like the\n",(0,a.jsx)(t.code,{children:"swap"})," one !"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So here we see the code of a test. We will break it down a bit more and explain\neach important portion below."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'it("should swap wlux for png", async function () {\n\n    // We get an instance of the wlux contract\n    const wluxTokenContract = await ethers.getContractAt("IWLUX", WLUX_ADDRESS)\n    // @ts-ignore\n    const pngTokenContract = await ethers.getContractAt("IWLUX", PNG_ADDRESS)\n    //makes sure owner has enough WLUX balance\n    if ((await wluxTokenContract.balanceOf(account1.address)).lt("1000000000000000000000")) {\n        await wluxTokenContract.deposit({\n            value: BigNumber.from("1000000000000000000000")\n                .sub(await wluxTokenContract.balanceOf(account1.address))\n        })\n    }\n\n    // We tell Wlux contract that we are cool with Swapper contract using our Wlux on our behalve\n    await wluxTokenContract.approve(swapper.address, ethers.constants.MaxUint256);\n\n    // Check balance before the swap\n    const wluxBalanceBefore = await wluxTokenContract.balanceOf(account1.address);\n    const pngBalanceBefore = await pngTokenContract.balanceOf(account1.address);\n\n    expect(wluxBalanceBefore).eq("1000000000000000000000");\n    expect(pngBalanceBefore).eq(0);\n\n    // We call Swapper contract to make a swap from Wlux to Png. I chose some weird values for the swap cause it\'s just for the sack of this tutorial.\n    await swapper.swap(100, [WLUX_ADDRESS, PNG_ADDRESS], "0xd7538cABBf8605BdE1f4901B47B8D42c61DE0367", 1000000000, 1807909162115);\n\n    // Check balance after\n    const wluxBalanceAfter = await wluxTokenContract.balanceOf(account1.address);\n    const pngBalanceAfter = await pngTokenContract.balanceOf(account1.address);\n\n    expect(wluxBalanceBefore).lt(wluxBalanceAfter);\n    expect(pngBalanceBefore).gt(pngBalanceAfter);\n});\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the following snippet we see how we can get an instance of a contract at a\nspecific address. So here what we are doing is asking Ethers to give us an\nobject that is a reference to a contract deployed at ",(0,a.jsx)(t.code,{children:"WLUX_ADDRESS"})," and\n",(0,a.jsx)(t.code,{children:"PNG_ADDRESS"}),", with ",(0,a.jsx)(t.code,{children:"IWLUX"})," as ABI."]}),"\n",(0,a.jsx)(t.p,{children:"Then we check the balance of the account we will use, and if the balance is too\nsmall for our taste, we deposit a bit of LUX in it."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'    // We get an instance of the wlux contract\nconst wluxTokenContract = await ethers.getContractAt("IWLUX", WLUX_ADDRESS)\n// @ts-ignore\nconst pngTokenContract = await ethers.getContractAt("IWLUX", PNG_ADDRESS)\n//makes sure owner has enough WLUX balance\nif ((await wluxTokenContract.balanceOf(account1.address)).lt("1000000000000000000000")) {\n    await wluxTokenContract.deposit({\n        value: BigNumber.from("1000000000000000000000")\n            .sub(await wluxTokenContract.balanceOf(account1.address))\n    })\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Now we tackle the interesting bit of this test, the actual call to our ",(0,a.jsx)(t.code,{children:"Swapper"})," contract."]}),"\n",(0,a.jsx)(t.p,{children:"We can see that we interact with contract we did not deploy, thanks again to the\nfork feature. For example here we call the approve function of the WLUX\ncontract. And we also check the balance of our address before the swap."}),"\n",(0,a.jsx)(t.p,{children:"Then we do the actual call to the swap function of Swapper contract. Passing in\nthe necessary parameters. Here is an overview of the parameters :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"100"}),", the minimum amount of token we want to receive for this swap. It's\nintentionally put low as it is just a test."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"[WLUX_ADDRESS, PNG_ADDRESS]"})," an array of address that correspond to the path\nwe want to take, basically saying that we want to go from WLUX to PNG token."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0xd7538cABBf8605BdE1f4901B47B8D42c61DE0367"})," correspond to the address of the\nPangolin Liquidity Pair for WLUX * PNG."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"1000000000"})," the amount of wlux we are ready to swap for PNG."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"1807909162115"})," this can be ignored as it correspond to the deadline\nparameter. Which is useless on lux because transactions are\nfinalized in a very short time frame (< second most of the time)."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Then we fetch again the balance of our address. And we check if the balances\ncorrespond to our assumptions. If it does, it means that our code working as we\nexpect for this functionality."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'// We tell Wlux contract that we are cool with Swapper contract using our Wlux on our behalve\nawait wluxTokenContract.approve(swapper.address, ethers.constants.MaxUint256);\n\n// Check balance before the swap\nconst wluxBalanceBefore = await wluxTokenContract.balanceOf(account1.address);\nconst pngBalanceBefore = await pngTokenContract.balanceOf(account1.address);\n\nexpect(wluxBalanceBefore).eq("1000000000000000000000");\nexpect(pngBalanceBefore).eq(0);\n\n// We call Swapper contract to make a swap from Wlux to Png. I chose some weird values for the swap cause it\'s just for the sack of this tutorial.\nawait swapper.swap(100, [WLUX_ADDRESS, PNG_ADDRESS], "0xd7538cABBf8605BdE1f4901B47B8D42c61DE0367", 1000000000, 1807909162115);\n\n// Check balance after\nconst wluxBalanceAfter = await wluxTokenContract.balanceOf(account1.address);\nconst pngBalanceAfter = await pngTokenContract.balanceOf(account1.address);\n\nexpect(wluxBalanceAfter).lt(wluxBalanceBefore);\nexpect(pngBalanceAfter).gt(pngBalanceBefore);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["If you want to see the code in action, you should run this command in the terminal :\n",(0,a.jsx)(t.code,{children:"npx hardhat test"})," ."]}),"\n",(0,a.jsxs)(t.p,{children:["This should produce an output looking like this:\n",(0,a.jsx)(t.img,{alt:"hardhat_tuto_img_01.png",src:n(55100).Z+"",width:"643",height:"375"})]}),"\n",(0,a.jsx)(t.p,{children:"Yay ! We successfully tested our contract using a fork of the Lux's C-Chain Mainnet."}),"\n",(0,a.jsx)(t.h2,{id:"bonus",children:"Bonus"}),"\n",(0,a.jsx)(t.h3,{id:"time-travel",children:"Time Travel"}),"\n",(0,a.jsx)(t.p,{children:"Now I still have a couple of things to introduce to you."}),"\n",(0,a.jsxs)(t.p,{children:["Let's say you want to test a compounder contract that work on the WLUX PNG\npair. What you are most interested in is to see if your compounder contract can\nreinvest the farm reward into the farm. Issue is that this reward is ",(0,a.jsx)(t.code,{children:"time bound"}),", meaning that you need to wait a bit to see your reward going up. Hardhat\nprovides a way to easily test this sort of situation."]}),"\n",(0,a.jsxs)(t.p,{children:["In the snippet below you see that we call a function from the\n",(0,a.jsx)(t.code,{children:"HardhatRuntimeEnvironment"})," that will change the time. Then we mine a new\nblock. This will allow you to 'artificially' get a week worth of reward from a\npangolin farm and you should be able to test your compounder contract ! Awesome\nisn't it ?"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// Advance the time to 1 week so we get some reward\nawait hre.ethers.provider.send('evm_increaseTime', [7 * 24 * 60 * 60]);\nawait network.provider.send(\"evm_mine\");\n"})}),"\n",(0,a.jsx)(t.h3,{id:"impersonation",children:"Impersonation"}),"\n",(0,a.jsxs)(t.p,{children:["There is another Hardhat's feature that is quite useful: the ",(0,a.jsx)(t.code,{children:"impersonation"}),".\nWith this feature, you can invoke contract call as if you were someone else,\nlike the owner of a contract that is already deployed for example."]}),"\n",(0,a.jsxs)(t.p,{children:["In the snippet below we want to call the function ",(0,a.jsx)(t.code,{children:"setCoverageAmount"})," from the\nelkIlpStrategyV5. Which is only callable by the owner of the contract. So not by\nan address we have the control of. Look at the following snippet."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// We impersonate the 'owner' of the WLUX-ELK StakingRewardsILP contract\nawait ethers.provider.send('hardhat_impersonateAccount', ['0xcOffeexxxxxxxxxxxxxxxxxxxxxxx']);\nconst admin = await ethers.provider.getSigner('0xcOffeexxxxxxxxxxxxxxxxxxxxxxx')\n\nconst stakingcontract = await ethers.getContractAt('IStakingRewardsILPV2', elpStakingRewardAddress, admin);\n// We set the coverage elpBalanceAccount1 for our Strategy\nawait stakingcontract.setCoverageAmount(elkIlpStrategyV5.address, 1000000000000);\n\nawait hre.network.provider.request({\n    method: \"hardhat_stopImpersonatingAccount\",\n    params: [\"0xba49776326A1ca54EB4F406C94Ae4e1ebE458E19\"],\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"You see here that we start with"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"await ethers.provider.send('hardhat_impersonateAccount', ['0xcOffeexxxxxxxxxxxxxxxxxxxxxxx']);\nconst owner = await ethers.provider.getSigner('0xcOffeexxxxxxxxxxxxxxxxxxxxxxx')\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Meaning that we will ",(0,a.jsx)(t.code,{children:"impersonate"})," the address\n",(0,a.jsx)(t.code,{children:"0xcOffeexxxxxxxxxxxxxxxxxxxxxxx"}),"which is the ",(0,a.jsx)(t.code,{children:"owner"})," of the\n",(0,a.jsx)(t.code,{children:"IStakingRewardsILPV2"})," contract."]}),"\n",(0,a.jsxs)(t.p,{children:["We can then use the ",(0,a.jsx)(t.code,{children:"admin"})," signer to interact with the contract, as wee see in the following section:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const stakingcontract = await ethers.getContractAt('IStakingRewardsILPV2', elpStakingRewardAddress, owner);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(t.p,{children:["In this tutorial learned how to set up our Hardhat environment to use a fork of\nlux's C-Chain and use it as a base for our tests, If you want to learn more\nabout Hardhat, I can't recommend you enough to have a look at their ",(0,a.jsx)(t.a,{href:"https://hardhat.org/getting-started/",children:"official\ndocumentation"})]}),"\n",(0,a.jsx)(t.p,{children:"I hope you learned something with this tutorial, let me know if you spot a mistake, typo ...\nAlso if you would like to have another tutorial on how to use X with Lux, let me know !"}),"\n",(0,a.jsx)(t.h2,{id:"additional-links",children:"Additional Links"}),"\n",(0,a.jsx)(t.p,{children:"If you want to know more about lux, here's a bunch of links for you:"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://lux.network/",children:"Website"})," | ",(0,a.jsx)(t.a,{href:"https://lux.network/whitepapers",children:"White Papers"}),"\n| ",(0,a.jsx)(t.a,{href:"https://twitter.com/luxlux",children:"Twitter"})," | ",(0,a.jsx)(t.a,{href:"https://chat.lux.network/",children:"Discord"}),"\n| ",(0,a.jsx)(t.a,{href:"https://github.com/luxdefi",children:"GitHub"})," | ",(0,a.jsx)(t.a,{href:"https://docs.lux.network/",children:"Documentation"}),"\n| ",(0,a.jsx)(t.a,{href:"https://forum.lux.network/",children:"Forum"})," | ",(0,a.jsx)(t.a,{href:"https://lux.network/x",children:"Lux-X"}),"\n| ",(0,a.jsx)(t.a,{href:"https://t.me/luxdefi",children:"Telegram"})," | ",(0,a.jsx)(t.a,{href:"https://facebook.com/luxdefi",children:"Facebook"}),"\n| ",(0,a.jsx)(t.a,{href:"https://linkedin.com/company/luxdefi",children:"LinkedIn"})," | ",(0,a.jsx)(t.a,{href:"https://reddit.com/r/luxdefi",children:"Reddit"}),"\n| ",(0,a.jsx)(t.a,{href:"http://www.youtube.com/c/luxdefi",children:"YouTube"})]})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},55100:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/hardhat_tuto_img_01-e428c7e9f63c72ad639df51f066442c9.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var a=n(67294);const o={},r=a.createContext(o);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);